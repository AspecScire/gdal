/* automatically generated by rust-bindgen */

pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type FILE = _IO_FILE;
pub type va_list = __builtin_va_list;
pub type _IO_lock_t = libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: libc::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut libc::c_void,
    pub __pad2: *mut libc::c_void,
    pub __pad3: *mut libc::c_void,
    pub __pad4: *mut libc::c_void,
    pub __pad5: usize,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type GInt32 = libc::c_int;
pub type GUInt32 = libc::c_uint;
pub type GInt16 = libc::c_short;
pub type GByte = libc::c_uchar;
pub type GIntBig = libc::c_longlong;
pub type GUIntBig = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(
        ::std::mem::size_of::<stat>(),
        144usize,
        concat!("Size of: ", stringify!(stat))
    );
    assert_eq!(
        ::std::mem::align_of::<stat>(),
        8usize,
        concat!("Alignment of ", stringify!(stat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_dev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_dev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ino as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_nlink as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_nlink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_uid as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_gid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__pad0 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_rdev as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_rdev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blksize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_blocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_atim as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_atim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_mtim as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_mtim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).st_ctim as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(st_ctim)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<stat>())).__glibc_reserved as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stat),
            "::",
            stringify!(__glibc_reserved)
        )
    );
}
extern "C" {
    pub fn VSIFOpen(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn VSIFClose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFSeek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn VSIRewind(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFFlush(arg1: *mut FILE);
}
extern "C" {
    pub fn VSIFRead(arg1: *mut libc::c_void, arg2: usize, arg3: usize, arg4: *mut FILE) -> usize;
}
extern "C" {
    pub fn VSIFWrite(arg1: *const libc::c_void, arg2: usize, arg3: usize, arg4: *mut FILE)
        -> usize;
}
extern "C" {
    pub fn VSIFGets(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIFPuts(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPrintf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn VSIFGetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPutc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIUngetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFEof(arg1: *mut FILE) -> libc::c_int;
}
pub type VSIStatBuf = stat;
extern "C" {
    pub fn VSIStat(arg1: *const libc::c_char, arg2: *mut VSIStatBuf) -> libc::c_int;
}
pub type vsi_l_offset = GUIntBig;
pub type VSILFILE = FILE;
extern "C" {
    pub fn VSIFOpenL(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIFCloseL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFSeekL(arg1: *mut VSILFILE, arg2: vsi_l_offset, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTellL(arg1: *mut VSILFILE) -> vsi_l_offset;
}
extern "C" {
    pub fn VSIRewindL(arg1: *mut VSILFILE);
}
extern "C" {
    pub fn VSIFReadL(
        arg1: *mut libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFReadMultiRangeL(
        nRanges: libc::c_int,
        ppData: *mut *mut libc::c_void,
        panOffsets: *const vsi_l_offset,
        panSizes: *const usize,
        arg1: *mut VSILFILE,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIFWriteL(
        arg1: *const libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: *mut VSILFILE,
    ) -> usize;
}
extern "C" {
    pub fn VSIFEofL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFTruncateL(arg1: *mut VSILFILE, arg2: vsi_l_offset) -> libc::c_int;
}
extern "C" {
    pub fn VSIFFlushL(arg1: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPrintfL(arg1: *mut VSILFILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn VSIFPutcL(arg1: libc::c_int, arg2: *mut VSILFILE) -> libc::c_int;
}
extern "C" {
    pub fn VSIIngestFile(
        fp: *mut VSILFILE,
        pszFilename: *const libc::c_char,
        ppabyRet: *mut *mut GByte,
        pnSize: *mut vsi_l_offset,
        nMaxSize: GIntBig,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat64 {
    _unused: [u8; 0],
}
pub type VSIStatBufL = stat64;
extern "C" {
    pub fn VSIStatL(arg1: *const libc::c_char, arg2: *mut VSIStatBufL) -> libc::c_int;
}
extern "C" {
    pub fn VSIStatExL(
        pszFilename: *const libc::c_char,
        psStatBuf: *mut VSIStatBufL,
        nFlags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn VSIIsCaseSensitiveFS(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIFGetNativeFileDescriptorL(arg1: *mut VSILFILE) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSICalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIFree(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn VSIRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn VSIStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    /// VSIMalloc2 allocates (nSize1 * nSize2) bytes.
    /// In case of overflow of the multiplication, or if memory allocation fails, a
    /// NULL pointer is returned and a CE_Failure error is raised with CPLError().
    /// If nSize1 == 0 || nSize2 == 0, a NULL pointer will also be returned.
    /// CPLFree() or VSIFree() can be used to free memory allocated by this function.
    pub fn VSIMalloc2(nSize1: usize, nSize2: usize) -> *mut libc::c_void;
}
extern "C" {
    /// VSIMalloc3 allocates (nSize1 * nSize2 * nSize3) bytes.
    /// In case of overflow of the multiplication, or if memory allocation fails, a
    /// NULL pointer is returned and a CE_Failure error is raised with CPLError().
    /// If nSize1 == 0 || nSize2 == 0 || nSize3 == 0, a NULL pointer will also be returned.
    /// CPLFree() or VSIFree() can be used to free memory allocated by this function.
    pub fn VSIMalloc3(nSize1: usize, nSize2: usize, nSize3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLGetPhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn CPLGetUsablePhysicalRAM() -> GIntBig;
}
extern "C" {
    pub fn VSIReadDir(arg1: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIReadDirRecursive(pszPath: *const libc::c_char) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn VSIMkdir(pathname: *const libc::c_char, mode: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn VSIRmdir(pathname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIUnlink(pathname: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIRename(oldpath: *const libc::c_char, newpath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn VSIStrerror(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn VSIInstallMemFileHandler();
}
extern "C" {
    pub fn VSIInstallLargeFileHandler();
}
extern "C" {
    pub fn VSIInstallSubFileHandler();
}
extern "C" {
    pub fn VSIInstallCurlFileHandler();
}
extern "C" {
    pub fn VSIInstallCurlStreamingFileHandler();
}
extern "C" {
    pub fn VSIInstallGZipFileHandler();
}
extern "C" {
    pub fn VSIInstallZipFileHandler();
}
extern "C" {
    pub fn VSIInstallStdinHandler();
}
extern "C" {
    pub fn VSIInstallStdoutHandler();
}
extern "C" {
    pub fn VSIInstallSparseFileHandler();
}
extern "C" {
    pub fn VSIInstallTarFileHandler();
}
extern "C" {
    pub fn VSICleanupFileManager();
}
extern "C" {
    pub fn VSIFileFromMemBuffer(
        pszFilename: *const libc::c_char,
        pabyData: *mut GByte,
        nDataLength: vsi_l_offset,
        bTakeOwnership: libc::c_int,
    ) -> *mut VSILFILE;
}
extern "C" {
    pub fn VSIGetMemFileBuffer(
        pszFilename: *const libc::c_char,
        pnDataLength: *mut vsi_l_offset,
        bUnlinkAndSeize: libc::c_int,
    ) -> *mut GByte;
}
pub type VSIWriteFunction = ::std::option::Option<
    unsafe extern "C" fn(ptr: *const libc::c_void, size: usize, nmemb: usize, stream: *mut FILE)
        -> usize,
>;
extern "C" {
    pub fn VSIStdoutSetRedirection(pFct: VSIWriteFunction, stream: *mut FILE);
}
extern "C" {
    pub fn VSITime(arg1: *mut libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
    pub fn VSICTime(arg1: libc::c_ulong) -> *const libc::c_char;
}
extern "C" {
    pub fn VSIGMTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn VSILocalTime(pnTime: *const time_t, poBrokenTime: *mut tm) -> *mut tm;
}
pub mod CPLErr {
    /// \file cpl_error.h
    ///
    /// CPL error handling services.
    pub type Type = u32;
    pub const CE_None: Type = 0;
    pub const CE_Debug: Type = 1;
    pub const CE_Warning: Type = 2;
    pub const CE_Failure: Type = 3;
    pub const CE_Fatal: Type = 4;
}
extern "C" {
    pub fn CPLError(eErrClass: CPLErr::Type, err_no: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    pub fn CPLErrorV(
        arg1: CPLErr::Type,
        arg2: libc::c_int,
        arg3: *const libc::c_char,
        arg4: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn CPLEmergencyError(arg1: *const libc::c_char);
}
extern "C" {
    pub fn CPLErrorReset();
}
extern "C" {
    pub fn CPLGetLastErrorNo() -> libc::c_int;
}
extern "C" {
    pub fn CPLGetLastErrorType() -> CPLErr::Type;
}
extern "C" {
    pub fn CPLGetLastErrorMsg() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetErrorHandlerUserData() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLErrorSetState(
        eErrClass: CPLErr::Type,
        err_no: libc::c_int,
        pszMsg: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLCleanupErrorMutex();
}
pub type CPLErrorHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: CPLErr::Type, arg2: libc::c_int, arg3: *const libc::c_char),
>;
extern "C" {
    pub fn CPLLoggingErrorHandler(arg1: CPLErr::Type, arg2: libc::c_int, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLDefaultErrorHandler(arg1: CPLErr::Type, arg2: libc::c_int, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLQuietErrorHandler(arg1: CPLErr::Type, arg2: libc::c_int, arg3: *const libc::c_char);
}
extern "C" {
    pub fn CPLTurnFailureIntoWarning(bOn: libc::c_int);
}
extern "C" {
    pub fn CPLSetErrorHandler(arg1: CPLErrorHandler) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLSetErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut libc::c_void) -> CPLErrorHandler;
}
extern "C" {
    pub fn CPLPushErrorHandler(arg1: CPLErrorHandler);
}
extern "C" {
    pub fn CPLPushErrorHandlerEx(arg1: CPLErrorHandler, arg2: *mut libc::c_void);
}
extern "C" {
    pub fn CPLPopErrorHandler();
}
extern "C" {
    pub fn CPLDebug(arg1: *const libc::c_char, arg2: *const libc::c_char, ...);
}
extern "C" {
    /// \file cpl_conv.h
    ///
    /// Various convenience functions for CPL.
    ///
    pub fn CPLVerifyConfiguration();
}
extern "C" {
    pub fn CPLGetConfigOption(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLSetConfigOption(arg1: *const libc::c_char, arg2: *const libc::c_char);
}
extern "C" {
    pub fn CPLSetThreadLocalConfigOption(
        pszKey: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLFreeConfig();
}
extern "C" {
    pub fn CPLMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLStrlwr(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLFGets(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut FILE,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLReadLine(arg1: *mut FILE) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLineL(arg1: *mut VSILFILE) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLReadLine2L(
        arg1: *mut VSILFILE,
        nMaxCols: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLAtof(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLAtofDelim(arg1: *const libc::c_char, arg2: libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtod(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLStrtodDelim(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn CPLStrtof(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn CPLStrtofDelim(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_char,
    ) -> f32;
}
extern "C" {
    pub fn CPLAtofM(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLScanString(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLScanDouble(arg1: *const libc::c_char, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn CPLScanLong(arg1: *const libc::c_char, arg2: libc::c_int) -> libc::c_long;
}
extern "C" {
    pub fn CPLScanULong(arg1: *const libc::c_char, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn CPLScanUIntBig(arg1: *const libc::c_char, arg2: libc::c_int) -> GUIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBig(pszString: *const libc::c_char) -> GIntBig;
}
extern "C" {
    pub fn CPLAtoGIntBigEx(
        pszString: *const libc::c_char,
        bWarn: libc::c_int,
        pbOverflow: *mut libc::c_int,
    ) -> GIntBig;
}
extern "C" {
    pub fn CPLScanPointer(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLPrintString(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintStringFill(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintInt32(arg1: *mut libc::c_char, arg2: GInt32, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintUIntBig(
        arg1: *mut libc::c_char,
        arg2: GUIntBig,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintDouble(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: f64,
        arg4: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintTime(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *const libc::c_char,
        arg4: *const tm,
        arg5: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLPrintPointer(
        arg1: *mut libc::c_char,
        arg2: *mut libc::c_void,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLGetSymbol(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLGetExecPath(pszPathBuf: *mut libc::c_char, nMaxLength: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn CPLGetPath(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetDirname(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetFilename(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetBasename(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetExtension(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetCurrentDir() -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLFormFilename(
        pszPath: *const libc::c_char,
        pszBasename: *const libc::c_char,
        pszExtension: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLFormCIFilename(
        pszPath: *const libc::c_char,
        pszBasename: *const libc::c_char,
        pszExtension: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLResetExtension(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLProjectRelativeFilename(
        pszProjectDir: *const libc::c_char,
        pszSecondaryFilename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLIsFilenameRelative(pszFilename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLExtractRelativePath(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCleanTrailingSlash(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCorrespondingPaths(
        pszOldFilename: *const libc::c_char,
        pszNewFilename: *const libc::c_char,
        papszFileList: *mut *mut libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn CPLCheckForFile(
        pszFilename: *mut libc::c_char,
        papszSiblingList: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLGenerateTempFilename(pszStem: *const libc::c_char) -> *const libc::c_char;
}
pub type CPLFileFinder = ::std::option::Option<
    unsafe extern "C" fn(arg1: *const libc::c_char, arg2: *const libc::c_char)
        -> *const libc::c_char,
>;
extern "C" {
    pub fn CPLFindFile(
        pszClass: *const libc::c_char,
        pszBasename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLDefaultFindFile(
        pszClass: *const libc::c_char,
        pszBasename: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLPushFileFinder(pfnFinder: CPLFileFinder);
}
extern "C" {
    pub fn CPLPopFileFinder() -> CPLFileFinder;
}
extern "C" {
    pub fn CPLPushFinderLocation(arg1: *const libc::c_char);
}
extern "C" {
    pub fn CPLPopFinderLocation();
}
extern "C" {
    pub fn CPLFinderClean();
}
extern "C" {
    pub fn CPLStat(arg1: *const libc::c_char, arg2: *mut VSIStatBuf) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLSharedFileInfo {
    pub fp: *mut FILE,
    pub nRefCount: libc::c_int,
    pub bLarge: libc::c_int,
    pub pszFilename: *mut libc::c_char,
    pub pszAccess: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_CPLSharedFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<CPLSharedFileInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CPLSharedFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLSharedFileInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLSharedFileInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).nRefCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(nRefCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).bLarge as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(bLarge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).pszFilename as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(pszFilename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLSharedFileInfo>())).pszAccess as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLSharedFileInfo),
            "::",
            stringify!(pszAccess)
        )
    );
}
extern "C" {
    pub fn CPLOpenShared(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn CPLCloseShared(arg1: *mut FILE);
}
extern "C" {
    pub fn CPLGetSharedList(arg1: *mut libc::c_int) -> *mut CPLSharedFileInfo;
}
extern "C" {
    pub fn CPLDumpSharedList(arg1: *mut FILE);
}
extern "C" {
    pub fn CPLCleanupSharedFileMutex();
}
extern "C" {
    pub fn CPLDMSToDec(is: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn CPLDecToDMS(
        dfAngle: f64,
        pszAxis: *const libc::c_char,
        nPrecision: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn CPLDecToPackedDMS(dfDec: f64) -> f64;
}
extern "C" {
    pub fn CPLStringToComplex(pszString: *const libc::c_char, pdfReal: *mut f64, pdfImag: *mut f64);
}
extern "C" {
    pub fn CPLUnlinkTree(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn CPLCopyFile(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCopyTree(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLMoveFile(
        pszNewPath: *const libc::c_char,
        pszOldPath: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateZip(
        pszZipFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateFileInZip(
        hZip: *mut libc::c_void,
        pszFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLWriteFileInZip(
        hZip: *mut libc::c_void,
        pBuffer: *const libc::c_void,
        nBufferSize: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseFileInZip(hZip: *mut libc::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLCloseZip(hZip: *mut libc::c_void) -> CPLErr::Type;
}
extern "C" {
    pub fn CPLZLibDeflate(
        ptr: *const libc::c_void,
        nBytes: usize,
        nLevel: libc::c_int,
        outptr: *mut libc::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLZLibInflate(
        ptr: *const libc::c_void,
        nBytes: usize,
        outptr: *mut libc::c_void,
        nOutAvailableBytes: usize,
        pnOutBytes: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLValidateXML(
        pszXMLFilename: *const libc::c_char,
        pszXSDFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLsetlocale(category: libc::c_int, locale: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLCleanupSetlocaleMutex();
}
pub type GDALProgressFunc = ::std::option::Option<
    unsafe extern "C" fn(
        dfComplete: f64,
        pszMessage: *const libc::c_char,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALDummyProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALTermProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALScaledProgress(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateScaledProgress(
        arg1: f64,
        arg2: f64,
        arg3: GDALProgressFunc,
        arg4: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyScaledProgress(arg1: *mut libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLVirtualMem {
    _unused: [u8; 0],
}
/// Callback triggered when a still unmapped page of virtual memory is accessed.
/// The callback has the responsibility of filling the page with relevant values
///
/// @param ctxt virtual memory handle.
/// @param nOffset offset of the page in the memory mapping.
/// @param pPageToFill address of the page to fill. Note that the address might
/// be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.
/// @param nToFill number of bytes of the page.
/// @param pUserData user data that was passed to CPLVirtualMemNew().
pub type CPLVirtualMemCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToFill: *mut libc::c_void,
        nToFill: usize,
        pUserData: *mut libc::c_void,
    ),
>;
/// Callback triggered when a dirty mapped page is going to be freed.
/// (saturation of cache, or termination of the virtual memory mapping).
///
/// @param ctxt virtual memory handle.
/// @param nOffset offset of the page in the memory mapping.
/// @param pPageToBeEvicted address of the page that will be flushed. Note that the address might
/// be a temporary location, and not at CPLVirtualMemGetAddr() + nOffset.
/// @param nToBeEvicted number of bytes of the page.
/// @param pUserData user data that was passed to CPLVirtualMemNew().
pub type CPLVirtualMemUnCachePageCbk = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: *mut CPLVirtualMem,
        nOffset: usize,
        pPageToBeEvicted: *const libc::c_void,
        nToBeEvicted: usize,
        pUserData: *mut libc::c_void,
    ),
>;
/// Callback triggered when a virtual memory mapping is destroyed.
/// @param pUserData user data that was passed to CPLVirtualMemNew().
pub type CPLVirtualMemFreeUserData =
    ::std::option::Option<unsafe extern "C" fn(pUserData: *mut libc::c_void)>;
pub mod CPLVirtualMemAccessMode {
    /// Access mode of a virtual memory mapping.
    pub type Type = u32;
    /// The mapping is meant at being read-only, but writes will not be prevented.
    /// Note that any content written will be lost.
    pub const VIRTUALMEM_READONLY: Type = 0;
    /// The mapping is meant at being read-only, and this will be enforced
    /// through the operating system page protection mechanism.
    pub const VIRTUALMEM_READONLY_ENFORCED: Type = 1;
    /// The mapping is meant at being read-write, and modified pages can be saved
    /// thanks to the pfnUnCachePage callback
    pub const VIRTUALMEM_READWRITE: Type = 2;
}
extern "C" {
    /// Return the size of a page of virtual memory.
    ///
    /// @return the page size.
    ///
    /// @since GDAL 1.11
    pub fn CPLGetPageSize() -> usize;
}
extern "C" {
    /// Create a new virtual memory mapping.
    ///
    /// This will reserve an area of virtual memory of size nSize, whose size
    /// might be potentially much larger than the physical memory available. Initially,
    /// no physical memory will be allocated. As soon as memory pages will be accessed,
    /// they will be allocated transparently and filled with the pfnCachePage callback.
    /// When the allowed cache size is reached, the least recently used pages will
    /// be unallocated.
    ///
    /// On Linux AMD64 platforms, the maximum value for nSize is 128 TB.
    /// On Linux x86 platforms, the maximum value for nSize is 2 GB.
    ///
    /// Only supported on Linux for now.
    ///
    /// Note that on Linux, this function will install a SIGSEGV handler. The
    /// original handler will be restored by CPLVirtualMemManagerTerminate().
    ///
    /// @param nSize size in bytes of the virtual memory mapping.
    /// @param nCacheSize   size in bytes of the maximum memory that will be really
    /// allocated (must ideally fit into RAM).
    /// @param nPageSizeHint hint for the page size. Must be a multiple of the
    /// system page size, returned by CPLGetPageSize().
    /// Minimum value is generally 4096. Might be set to 0 to
    /// let the function determine a default page size.
    /// @param bSingleThreadUsage set to TRUE if there will be no concurrent threads
    /// that will access the virtual memory mapping. This can
    /// optimize performance a bit.
    /// @param eAccessMode permission to use for the virtual memory mapping.
    /// @param pfnCachePage callback triggered when a still unmapped page of virtual
    /// memory is accessed. The callback has the responsibility
    /// of filling the page with relevant values.
    /// @param pfnUnCachePage callback triggered when a dirty mapped page is going to
    /// be freed (saturation of cache, or termination of the
    /// virtual memory mapping). Might be NULL.
    /// @param pfnFreeUserData callback that can be used to free pCbkUserData. Might be
    /// NULL
    /// @param pCbkUserData user data passed to pfnCachePage and pfnUnCachePage.
    ///
    /// @return a virtual memory object that must be freed by CPLVirtualMemFree(),
    /// or NULL in case of failure.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemNew(
        nSize: usize,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnCachePage: CPLVirtualMemCachePageCbk,
        pfnUnCachePage: CPLVirtualMemUnCachePageCbk,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    /// Return if virtual memory mapping of a file is available.
    ///
    /// @return TRUE if virtual memory mapping of a file is available.
    /// @since GDAL 1.11
    pub fn CPLIsVirtualMemFileMapAvailable() -> libc::c_int;
}
extern "C" {
    /// Create a new virtual memory mapping from a file.
    ///
    /// The file must be a "real" file recognized by the operating system, and not
    /// a VSI extended virtual file.
    ///
    /// In VIRTUALMEM_READWRITE mode, updates to the memory mapping will be written
    /// in the file.
    ///
    /// On Linux AMD64 platforms, the maximum value for nLength is 128 TB.
    /// On Linux x86 platforms, the maximum value for nLength is 2 GB.
    ///
    /// Only supported on Linux for now.
    ///
    /// @param  fp       Virtual file handle.
    /// @param  nOffset  Offset in the file to start the mapping from.
    /// @param  nLength  Length of the portion of the file to map into memory.
    /// @param eAccessMode Permission to use for the virtual memory mapping. This must
    /// be consistent with how the file has been opened.
    /// @param pfnFreeUserData callback that is called when the object is destroyed.
    /// @param pCbkUserData user data passed to pfnFreeUserData.
    /// @return a virtual memory object that must be freed by CPLVirtualMemFree(),
    /// or NULL in case of failure.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemFileMapNew(
        fp: *mut VSILFILE,
        nOffset: vsi_l_offset,
        nLength: vsi_l_offset,
        eAccessMode: CPLVirtualMemAccessMode::Type,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    /// Create a new virtual memory mapping derived from an other virtual memory
    /// mapping.
    ///
    /// This may be useful in case of creating mapping for pixel interleaved data.
    ///
    /// The new mapping takes a reference on the base mapping.
    ///
    /// @param pVMemBase Base virtual memory mapping
    /// @param nOffset   Offset in the base virtual memory mapping from which to start
    /// the new mapping.
    /// @param nSize     Size of the base virtual memory mapping to expose in the
    /// the new mapping.
    /// @param pfnFreeUserData callback that is called when the object is destroyed.
    /// @param pCbkUserData user data passed to pfnFreeUserData.
    /// @return a virtual memory object that must be freed by CPLVirtualMemFree(),
    /// or NULL in case of failure.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemDerivedNew(
        pVMemBase: *mut CPLVirtualMem,
        nOffset: vsi_l_offset,
        nSize: vsi_l_offset,
        pfnFreeUserData: CPLVirtualMemFreeUserData,
        pCbkUserData: *mut libc::c_void,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    /// Free a virtual memory mapping.
    ///
    /// The pointer returned by CPLVirtualMemGetAddr() will no longer be valid.
    /// If the virtual memory mapping was created with read/write permissions and that
    /// they are dirty (i.e. modified) pages, they will be flushed through the
    /// pfnUnCachePage callback before being freed.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemFree(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    /// Return the pointer to the start of a virtual memory mapping.
    ///
    /// The bytes in the range [p:p+CPLVirtualMemGetSize()-1] where p is the pointer
    /// returned by this function will be valid, until CPLVirtualMemFree() is called.
    ///
    /// Note that if a range of bytes used as an argument of a system call
    /// (such as read() or write()) contains pages that have not been "realized", the
    /// system call will fail with EFAULT. CPLVirtualMemPin() can be used to work
    /// around this issue.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @return the pointer to the start of a virtual memory mapping.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemGetAddr(ctxt: *mut CPLVirtualMem) -> *mut libc::c_void;
}
extern "C" {
    /// Return the size of the virtual memory mapping.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @return the size of the virtual memory mapping.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemGetSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    /// Return if the virtal memory mapping is a direct file mapping.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @return TRUE if the virtal memory mapping is a direct file mapping.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemIsFileMapping(ctxt: *mut CPLVirtualMem) -> libc::c_int;
}
extern "C" {
    /// Return the access mode of the virtual memory mapping.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @return the access mode of the virtual memory mapping.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemGetAccessMode(ctxt: *mut CPLVirtualMem) -> CPLVirtualMemAccessMode::Type;
}
extern "C" {
    /// Return the page size associated to a virtual memory mapping.
    ///
    /// The value returned will be at least CPLGetPageSize(), but potentially
    /// larger.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @return the page size
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemGetPageSize(ctxt: *mut CPLVirtualMem) -> usize;
}
extern "C" {
    /// Return TRUE if this memory mapping can be accessed safely from concurrent
    /// threads.
    ///
    /// The situation that can cause problems is when several threads try to access
    /// a page of the mapping that is not yet mapped.
    ///
    /// The return value of this function depends on whether bSingleThreadUsage has
    /// been set of not in CPLVirtualMemNew() and/or the implementation.
    ///
    /// On Linux, this will always return TRUE if bSingleThreadUsage = FALSE.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @return TRUE if this memory mapping can be accessed safely from concurrent
    /// threads.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemIsAccessThreadSafe(ctxt: *mut CPLVirtualMem) -> libc::c_int;
}
extern "C" {
    /// Declare that a thread will access a virtual memory mapping.
    ///
    /// This function must be called by a thread that wants to access the
    /// content of a virtual memory mapping, except if the virtual memory mapping has
    /// been created with bSingleThreadUsage = TRUE.
    ///
    /// This function must be paired with CPLVirtualMemUnDeclareThread().
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    /// Declare that a thread will stop accessing a virtual memory mapping.
    ///
    /// This function must be called by a thread that will no longer access the
    /// content of a virtual memory mapping, except if the virtual memory mapping has
    /// been created with bSingleThreadUsage = TRUE.
    ///
    /// This function must be paired with CPLVirtualMemDeclareThread().
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemUnDeclareThread(ctxt: *mut CPLVirtualMem);
}
extern "C" {
    /// Make sure that a region of virtual memory will be realized.
    ///
    /// Calling this function is not required, but might be useful when debugging
    /// a process with tools like gdb or valgrind that do not naturally like
    /// segmentation fault signals.
    ///
    /// It is also needed when wanting to provide part of virtual memory mapping
    /// to a system call such as read() or write(). If read() or write() is called
    /// on a memory region not yet realized, the call will fail with EFAULT.
    ///
    /// @param ctxt context returned by CPLVirtualMemNew().
    /// @param pAddr the memory region to pin.
    /// @param nSize the size of the memory region.
    /// @param bWriteOp set to TRUE if the memory are will be accessed in write mode.
    ///
    /// @since GDAL 1.11
    pub fn CPLVirtualMemPin(
        ctxt: *mut CPLVirtualMem,
        pAddr: *mut libc::c_void,
        nSize: usize,
        bWriteOp: libc::c_int,
    );
}
extern "C" {
    /// Cleanup any resource and handlers related to virtual memory.
    ///
    /// This function must be called after the last CPLVirtualMem object has
    /// been freed.
    ///
    /// @since GDAL 2.0
    pub fn CPLVirtualMemManagerTerminate();
}
pub mod CPLXMLNodeType {
    /// \file cpl_minixml.h
    ///
    /// Definitions for CPL mini XML Parser/Serializer.
    pub type Type = u32;
    /// Node is an element
    pub const CXT_Element: Type = 0;
    /// Node is a raw text value
    pub const CXT_Text: Type = 1;
    /// Node is attribute
    pub const CXT_Attribute: Type = 2;
    /// Node is an XML comment.
    pub const CXT_Comment: Type = 3;
    /// Node is a special literal
    pub const CXT_Literal: Type = 4;
}
/// Document node structure.
///
/// This C structure is used to hold a single text fragment representing a
/// component of the document when parsed.   It should be allocated with the
/// appropriate CPL function, and freed with CPLDestroyXMLNode().  The structure
/// contents should not normally be altered by application code, but may be
/// freely examined by application code.
///
/// Using the psChild and psNext pointers, a heirarchical tree structure
/// for a document can be represented as a tree of CPLXMLNode structures.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CPLXMLNode {
    /// \brief Node type
    ///
    /// One of CXT_Element, CXT_Text, CXT_Attribute, CXT_Comment,
    /// or CXT_Literal.
    pub eType: CPLXMLNodeType::Type,
    /// \brief Node value
    ///
    /// For CXT_Element this is the name of the element, without the angle
    /// brackets.  Note there is a single CXT_Element even when the document
    /// contains a start and end element tag.  The node represents the pair.
    /// All text or other elements between the start and end tag will appear
    /// as children nodes of this CXT_Element node.
    ///
    /// For CXT_Attribute the pszValue is the attribute name.  The value of
    /// the attribute will be a CXT_Text child.
    ///
    /// For CXT_Text this is the text itself (value of an attribute, or a
    /// text fragment between an element start and end tags.
    ///
    /// For CXT_Literal it is all the literal text.  Currently this is just
    /// used for !DOCTYPE lines, and the value would be the entire line.
    ///
    /// For CXT_Comment the value is all the literal text within the comment,
    /// but not including the comment start/end indicators ("<--" and "-->").
    pub pszValue: *mut libc::c_char,
    /// \brief Next sibling.
    ///
    /// Pointer to next sibling, that is the next node appearing after this
    /// one that has the same parent as this node.  NULL if this node is the
    /// last child of the parent element.
    pub psNext: *mut CPLXMLNode,
    /// \brief Child node.
    ///
    /// Pointer to first child node, if any.  Only CXT_Element and CXT_Attribute
    /// nodes should have children.  For CXT_Attribute it should be a single
    /// CXT_Text value node, while CXT_Element can have any kind of child.
    /// The full list of children for a node are identified by walking the
    /// psNext's starting with the psChild node.
    pub psChild: *mut CPLXMLNode,
}
#[test]
fn bindgen_test_layout_CPLXMLNode() {
    assert_eq!(
        ::std::mem::size_of::<CPLXMLNode>(),
        32usize,
        concat!("Size of: ", stringify!(CPLXMLNode))
    );
    assert_eq!(
        ::std::mem::align_of::<CPLXMLNode>(),
        8usize,
        concat!("Alignment of ", stringify!(CPLXMLNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).eType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(eType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).pszValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(pszValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).psNext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(psNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CPLXMLNode>())).psChild as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CPLXMLNode),
            "::",
            stringify!(psChild)
        )
    );
}
extern "C" {
    pub fn CPLParseXMLString(arg1: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLDestroyXMLNode(arg1: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLGetXMLNode(poRoot: *mut CPLXMLNode, pszPath: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSearchXMLNode(
        poRoot: *mut CPLXMLNode,
        pszTarget: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLGetXMLValue(
        poRoot: *mut CPLXMLNode,
        pszPath: *const libc::c_char,
        pszDefault: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn CPLCreateXMLNode(
        poParent: *mut CPLXMLNode,
        eType: CPLXMLNodeType::Type,
        pszText: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTree(psNode: *const CPLXMLNode) -> *mut libc::c_char;
}
extern "C" {
    pub fn CPLAddXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLRemoveXMLChild(psParent: *mut CPLXMLNode, psChild: *mut CPLXMLNode) -> libc::c_int;
}
extern "C" {
    pub fn CPLAddXMLSibling(psOlderSibling: *mut CPLXMLNode, psNewSibling: *mut CPLXMLNode);
}
extern "C" {
    pub fn CPLCreateXMLElementAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLAddXMLAttributeAndValue(
        psParent: *mut CPLXMLNode,
        pszName: *const libc::c_char,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn CPLCloneXMLTree(psTree: *mut CPLXMLNode) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSetXMLValue(
        psRoot: *mut CPLXMLNode,
        pszPath: *const libc::c_char,
        pszValue: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLStripXMLNamespace(
        psRoot: *mut CPLXMLNode,
        pszNameSpace: *const libc::c_char,
        bRecurse: libc::c_int,
    );
}
extern "C" {
    pub fn CPLCleanXMLElementName(arg1: *mut libc::c_char);
}
extern "C" {
    pub fn CPLParseXMLFile(pszFilename: *const libc::c_char) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn CPLSerializeXMLTreeToFile(
        psTree: *const CPLXMLNode,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
}
#[test]
fn bindgen_test_layout_OGREnvelope() {
    assert_eq!(
        ::std::mem::size_of::<OGREnvelope>(),
        32usize,
        concat!("Size of: ", stringify!(OGREnvelope))
    );
    assert_eq!(
        ::std::mem::align_of::<OGREnvelope>(),
        8usize,
        concat!("Alignment of ", stringify!(OGREnvelope))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MinX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MinX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MaxX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MaxX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MinY as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MinY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope>())).MaxY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope),
            "::",
            stringify!(MaxY)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGREnvelope3D {
    pub MinX: f64,
    pub MaxX: f64,
    pub MinY: f64,
    pub MaxY: f64,
    pub MinZ: f64,
    pub MaxZ: f64,
}
#[test]
fn bindgen_test_layout_OGREnvelope3D() {
    assert_eq!(
        ::std::mem::size_of::<OGREnvelope3D>(),
        48usize,
        concat!("Size of: ", stringify!(OGREnvelope3D))
    );
    assert_eq!(
        ::std::mem::align_of::<OGREnvelope3D>(),
        8usize,
        concat!("Alignment of ", stringify!(OGREnvelope3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MinX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MaxX as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MinY as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MaxY as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MinZ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MinZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGREnvelope3D>())).MaxZ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(OGREnvelope3D),
            "::",
            stringify!(MaxZ)
        )
    );
}
extern "C" {
    pub fn OGRMalloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRCalloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRRealloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn OGRStrdup(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGRFree(arg1: *mut libc::c_void);
}
pub mod OGRwkbGeometryType {
    /// List of well known binary geometry types.  These are used within the BLOBs
    /// but are also returned from OGRGeometry::getGeometryType() to identify the
    /// type of a geometry object.
    pub type Type = u32;
    /// < unknown type, non-standard
    pub const wkbUnknown: Type = 0;
    /// < 0-dimensional geometric object, standard WKB
    pub const wkbPoint: Type = 1;
    /// < 1-dimensional geometric object with linear
    /// interpolation between Points, standard WKB
    pub const wkbLineString: Type = 2;
    /// < planar 2-dimensional geometric object defined
    /// by 1 exterior boundary and 0 or more interior
    /// boundaries, standard WKB
    pub const wkbPolygon: Type = 3;
    /// < GeometryCollection of Points, standard WKB
    pub const wkbMultiPoint: Type = 4;
    /// < GeometryCollection of LineStrings, standard WKB
    pub const wkbMultiLineString: Type = 5;
    /// < GeometryCollection of Polygons, standard WKB
    pub const wkbMultiPolygon: Type = 6;
    /// < geometric object that is a collection of 1
    /// or more geometric objects, standard WKB
    pub const wkbGeometryCollection: Type = 7;
    /// < one or more circular arc segments connected end to end,
    /// ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbCircularString: Type = 8;
    /// < sequence of contiguous curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbCompoundCurve: Type = 9;
    /// < planar surface, defined by 1 exterior boundary
    /// and zero or more interior boundaries, that are curves.
    /// ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbCurvePolygon: Type = 10;
    /// < GeometryCollection of Curves, ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbMultiCurve: Type = 11;
    /// < GeometryCollection of Surfaces, ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbMultiSurface: Type = 12;
    /// < non-standard, for pure attribute records
    pub const wkbNone: Type = 100;
    /// < non-standard, just for createGeometry()
    pub const wkbLinearRing: Type = 101;
    /// < wkbCircularString with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbCircularStringZ: Type = 1008;
    /// < wkbCompoundCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbCompoundCurveZ: Type = 1009;
    /// < wkbCurvePolygon with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbCurvePolygonZ: Type = 1010;
    /// < wkbMultiCurve with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbMultiCurveZ: Type = 1011;
    /// < wkbMultiSurface with Z component. ISO SQL/MM Part 3. GDAL &gt;= 2.0
    pub const wkbMultiSurfaceZ: Type = 1012;
    /// < 2.5D extension as per 99-402
    pub const wkbPoint25D: Type = 2147483649;
    /// < 2.5D extension as per 99-402
    pub const wkbLineString25D: Type = 2147483650;
    /// < 2.5D extension as per 99-402
    pub const wkbPolygon25D: Type = 2147483651;
    /// < 2.5D extension as per 99-402
    pub const wkbMultiPoint25D: Type = 2147483652;
    /// < 2.5D extension as per 99-402
    pub const wkbMultiLineString25D: Type = 2147483653;
    /// < 2.5D extension as per 99-402
    pub const wkbMultiPolygon25D: Type = 2147483654;
    /// < 2.5D extension as per 99-402
    pub const wkbGeometryCollection25D: Type = 2147483655;
}
extern "C" {
    pub fn OGRGeometryTypeToName(eType: OGRwkbGeometryType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGRMergeGeometryTypes(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGRMergeGeometryTypesEx(
        eMain: OGRwkbGeometryType::Type,
        eExtra: OGRwkbGeometryType::Type,
        bAllowPromotingToCurves: libc::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_Flatten(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetZ(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_SetModifier(
        eType: OGRwkbGeometryType::Type,
        bSetZ: libc::c_int,
        bSetM: libc::c_int,
    ) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_HasZ(eType: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSubClassOf(
        eType: OGRwkbGeometryType::Type,
        eSuperType: OGRwkbGeometryType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsCurve(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsSurface(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_IsNonLinear(arg1: OGRwkbGeometryType::Type) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GT_GetCollection(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetCurve(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GT_GetLinear(eType: OGRwkbGeometryType::Type) -> OGRwkbGeometryType::Type;
}
pub mod OGRwkbByteOrder {
    pub type Type = u32;
    pub const wkbXDR: Type = 0;
    pub const wkbNDR: Type = 1;
}
pub mod OGRFieldType {
    /// List of feature field types.  This list is likely to be extended in the
    /// future ... avoid coding applications based on the assumption that all
    /// field types can be known.
    pub type Type = u32;
    /// Simple 32bit integer
    pub const OFTInteger: Type = 0;
    /// List of 32bit integers
    pub const OFTIntegerList: Type = 1;
    /// Double Precision floating point
    pub const OFTReal: Type = 2;
    /// List of doubles
    pub const OFTRealList: Type = 3;
    /// String of ASCII chars
    pub const OFTString: Type = 4;
    /// Array of strings
    pub const OFTStringList: Type = 5;
    /// deprecated
    pub const OFTWideString: Type = 6;
    /// deprecated
    pub const OFTWideStringList: Type = 7;
    /// Raw Binary data
    pub const OFTBinary: Type = 8;
    /// Date
    pub const OFTDate: Type = 9;
    /// Time
    pub const OFTTime: Type = 10;
    /// Date and Time
    pub const OFTDateTime: Type = 11;
    /// Single 64bit integer
    pub const OFTInteger64: Type = 12;
    /// List of 64bit integers
    pub const OFTInteger64List: Type = 13;
    /// List of 64bit integers
    pub const OFTMaxType: Type = 13;
}
pub mod OGRFieldSubType {
    /// List of field subtypes. A subtype represents a hint, a restriction of the
    /// main type, that is not strictly necessary to consult.
    /// This list is likely to be extended in the
    /// future ... avoid coding applications based on the assumption that all
    /// field types can be known.
    /// Most subtypes only make sense for a restricted set of main types.
    /// @since GDAL 2.0
    pub type Type = u32;
    /// No subtype. This is the default value
    pub const OFSTNone: Type = 0;
    /// Boolean integer. Only valid for OFTInteger and OFTIntegerList.
    pub const OFSTBoolean: Type = 1;
    /// Signed 16-bit integer. Only valid for OFTInteger and OFTIntegerList.
    pub const OFSTInt16: Type = 2;
    /// Single precision (32 bit) floatint point. Only valid for OFTReal and OFTRealList.
    pub const OFSTFloat32: Type = 3;
    /// Single precision (32 bit) floatint point. Only valid for OFTReal and OFTRealList.
    pub const OFSTMaxSubType: Type = 3;
}
pub mod OGRJustification {
    /// Display justification for field values.
    pub type Type = u32;
    pub const OJUndefined: Type = 0;
    pub const OJLeft: Type = 1;
    pub const OJRight: Type = 2;
}
/// OGRFeature field attribute value union.
#[repr(C)]
#[derive(Copy, Clone)]
pub union OGRField {
    pub Integer: libc::c_int,
    pub Integer64: GIntBig,
    pub Real: f64,
    pub String: *mut libc::c_char,
    pub IntegerList: OGRField__bindgen_ty_1,
    pub Integer64List: OGRField__bindgen_ty_2,
    pub RealList: OGRField__bindgen_ty_3,
    pub StringList: OGRField__bindgen_ty_4,
    pub Binary: OGRField__bindgen_ty_5,
    pub Set: OGRField__bindgen_ty_6,
    pub Date: OGRField__bindgen_ty_7,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_1 {
    pub nCount: libc::c_int,
    pub paList: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_1>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_1),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_1>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_1),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_2 {
    pub nCount: libc::c_int,
    pub paList: *mut GIntBig,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_2>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_2),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_2>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_2),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_3 {
    pub nCount: libc::c_int,
    pub paList: *mut f64,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_3>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_3),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_3>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_3),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_4 {
    pub nCount: libc::c_int,
    pub paList: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_4>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_4),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_4>())).paList as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_4),
            "::",
            stringify!(paList)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_5 {
    pub nCount: libc::c_int,
    pub paData: *mut GByte,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_5>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_5>())).nCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_5),
            "::",
            stringify!(nCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_5>())).paData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_5),
            "::",
            stringify!(paData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_6 {
    pub nMarker1: libc::c_int,
    pub nMarker2: libc::c_int,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_6>(),
        8usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_6>())).nMarker1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_6>())).nMarker2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_6),
            "::",
            stringify!(nMarker2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRField__bindgen_ty_7 {
    pub Year: GInt16,
    pub Month: GByte,
    pub Day: GByte,
    pub Hour: GByte,
    pub Minute: GByte,
    pub TZFlag: GByte,
    pub Reserved: GByte,
    pub Second: f32,
}
#[test]
fn bindgen_test_layout_OGRField__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<OGRField__bindgen_ty_7>(),
        12usize,
        concat!("Size of: ", stringify!(OGRField__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(OGRField__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Month as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Day as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Hour as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Minute as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).TZFlag as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(TZFlag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Reserved as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField__bindgen_ty_7>())).Second as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField__bindgen_ty_7),
            "::",
            stringify!(Second)
        )
    );
}
#[test]
fn bindgen_test_layout_OGRField() {
    assert_eq!(
        ::std::mem::size_of::<OGRField>(),
        16usize,
        concat!("Size of: ", stringify!(OGRField))
    );
    assert_eq!(
        ::std::mem::align_of::<OGRField>(),
        8usize,
        concat!("Alignment of ", stringify!(OGRField))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Integer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Integer64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Real)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).String as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(String)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).IntegerList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(IntegerList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Integer64List as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Integer64List)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).RealList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(RealList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).StringList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(StringList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Binary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Binary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<OGRField>())).Date as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OGRField),
            "::",
            stringify!(Date)
        )
    );
}
extern "C" {
    pub fn OGRParseDate(
        pszInput: *const libc::c_char,
        psOutput: *mut OGRField,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
pub mod ogr_style_tool_class_id {
    /// OGRStyleTool derived class types (returned by GetType()).
    pub type Type = u32;
    pub const OGRSTCNone: Type = 0;
    pub const OGRSTCPen: Type = 1;
    pub const OGRSTCBrush: Type = 2;
    pub const OGRSTCSymbol: Type = 3;
    pub const OGRSTCLabel: Type = 4;
    pub const OGRSTCVector: Type = 5;
}
pub use self::ogr_style_tool_class_id::Type as OGRSTClassId;
pub mod ogr_style_tool_units_id {
    /// List of units supported by OGRStyleTools.
    pub type Type = u32;
    pub const OGRSTUGround: Type = 0;
    pub const OGRSTUPixel: Type = 1;
    pub const OGRSTUPoints: Type = 2;
    pub const OGRSTUMM: Type = 3;
    pub const OGRSTUCM: Type = 4;
    pub const OGRSTUInches: Type = 5;
}
pub use self::ogr_style_tool_units_id::Type as OGRSTUnitId;
extern "C" {
    pub fn GDALVersionInfo(arg1: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    /// Return TRUE if GDAL library version at runtime matches nVersionMajor.nVersionMinor.
    ///
    /// The purpose of this method is to ensure that calling code will run with the GDAL
    /// version it is compiled for. It is primarly intented for external plugins.
    ///
    /// @param nVersionMajor Major version to be tested against
    /// @param nVersionMinor Minor version to be tested against
    /// @param pszCallingComponentName If not NULL, in case of version mismatch, the method
    /// will issue a failure mentionning the name of
    /// the calling component.
    pub fn GDALCheckVersion(
        nVersionMajor: libc::c_int,
        nVersionMinor: libc::c_int,
        pszCallingComponentName: *const libc::c_char,
    ) -> libc::c_int;
}
pub type OGRGeometryH = *mut libc::c_void;
pub type OGRSpatialReferenceH = *mut libc::c_void;
pub type OGRCoordinateTransformationH = *mut libc::c_void;
extern "C" {
    pub fn OGR_G_CreateFromWkb(
        arg1: *mut libc::c_uchar,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromWkt(
        arg1: *mut *mut libc::c_char,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_CreateFromFgf(
        arg1: *mut libc::c_uchar,
        arg2: OGRSpatialReferenceH,
        arg3: *mut OGRGeometryH,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_DestroyGeometry(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateGeometry(arg1: OGRwkbGeometryType::Type) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ApproximateArcAngles(
        dfCenterX: f64,
        dfCenterY: f64,
        dfZ: f64,
        dfPrimaryRadius: f64,
        dfSecondaryAxis: f64,
        dfRotation: f64,
        dfStartAngle: f64,
        dfEndAngle: f64,
        dfMaxAngleStepSizeDegrees: f64,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPolygon(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiPoint(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceToMultiLineString(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ForceTo(
        hGeom: OGRGeometryH,
        eTargetType: OGRwkbGeometryType::Type,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetCoordinateDimension(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_SetCoordinateDimension(arg1: OGRGeometryH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_G_Clone(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetEnvelope(arg1: OGRGeometryH, arg2: *mut OGREnvelope);
}
extern "C" {
    pub fn OGR_G_GetEnvelope3D(arg1: OGRGeometryH, arg2: *mut OGREnvelope3D);
}
extern "C" {
    pub fn OGR_G_ImportFromWkb(
        arg1: OGRGeometryH,
        arg2: *mut libc::c_uchar,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut libc::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkb(
        arg1: OGRGeometryH,
        arg2: OGRwkbByteOrder::Type,
        arg3: *mut libc::c_uchar,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_WkbSize(hGeom: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_ImportFromWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_ExportToIsoWkt(arg1: OGRGeometryH, arg2: *mut *mut libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryType(arg1: OGRGeometryH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_G_GetGeometryName(arg1: OGRGeometryH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_G_DumpReadable(arg1: OGRGeometryH, arg2: *mut FILE, arg3: *const libc::c_char);
}
extern "C" {
    pub fn OGR_G_FlattenTo2D(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CloseRings(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_CreateFromGML(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGML(arg1: OGRGeometryH) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToGMLEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_CreateFromGMLTree(arg1: *const CPLXMLNode) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ExportToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportEnvelopeToGMLTree(arg1: OGRGeometryH) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn OGR_G_ExportToKML(
        arg1: OGRGeometryH,
        pszAltitudeMode: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJson(arg1: OGRGeometryH) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_ExportToJsonEx(
        arg1: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn OGR_G_CreateGeometryFromJson(arg1: *const libc::c_char) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AssignSpatialReference(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_G_GetSpatialReference(arg1: OGRGeometryH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_G_Transform(arg1: OGRGeometryH, arg2: OGRCoordinateTransformationH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_TransformTo(arg1: OGRGeometryH, arg2: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_Simplify(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SimplifyPreserveTopology(hThis: OGRGeometryH, tolerance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Segmentize(hGeom: OGRGeometryH, dfMaxLength: f64);
}
extern "C" {
    pub fn OGR_G_Intersects(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Equals(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Disjoint(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Touches(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Crosses(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Within(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Contains(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Overlaps(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Boundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_ConvexHull(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Buffer(arg1: OGRGeometryH, arg2: f64, arg3: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Intersection(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Union(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_UnionCascaded(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_PointOnSurface(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Difference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_SymDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Distance(arg1: OGRGeometryH, arg2: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Length(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Area(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_Centroid(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Value(arg1: OGRGeometryH, dfDistance: f64) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Empty(arg1: OGRGeometryH);
}
extern "C" {
    pub fn OGR_G_IsEmpty(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsValid(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsSimple(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_IsRing(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Polygonize(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_Intersect(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_Equal(arg1: OGRGeometryH, arg2: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_SymmetricDifference(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetArea(arg1: OGRGeometryH) -> f64;
}
extern "C" {
    pub fn OGR_G_GetBoundary(arg1: OGRGeometryH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetPointCount(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetPoints(
        hGeom: OGRGeometryH,
        pabyX: *mut libc::c_void,
        nXStride: libc::c_int,
        pabyY: *mut libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *mut libc::c_void,
        nZStride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetX(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetY(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetZ(arg1: OGRGeometryH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_G_GetPoint(
        arg1: OGRGeometryH,
        iPoint: libc::c_int,
        arg2: *mut f64,
        arg3: *mut f64,
        arg4: *mut f64,
    );
}
extern "C" {
    pub fn OGR_G_SetPointCount(hGeom: OGRGeometryH, nNewPointCount: libc::c_int);
}
extern "C" {
    pub fn OGR_G_SetPoint(arg1: OGRGeometryH, iPoint: libc::c_int, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_SetPoint_2D(arg1: OGRGeometryH, iPoint: libc::c_int, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_AddPoint(arg1: OGRGeometryH, arg2: f64, arg3: f64, arg4: f64);
}
extern "C" {
    pub fn OGR_G_AddPoint_2D(arg1: OGRGeometryH, arg2: f64, arg3: f64);
}
extern "C" {
    pub fn OGR_G_SetPoints(
        hGeom: OGRGeometryH,
        nPointsIn: libc::c_int,
        pabyX: *mut libc::c_void,
        nXStride: libc::c_int,
        pabyY: *mut libc::c_void,
        nYStride: libc::c_int,
        pabyZ: *mut libc::c_void,
        nZStride: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_G_GetGeometryCount(arg1: OGRGeometryH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetGeometryRef(arg1: OGRGeometryH, arg2: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_AddGeometry(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_AddGeometryDirectly(arg1: OGRGeometryH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_RemoveGeometry(
        arg1: OGRGeometryH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_G_HasCurveGeometry(
        arg1: OGRGeometryH,
        bLookForNonLinear: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_G_GetLinearGeometry(
        hGeom: OGRGeometryH,
        dfMaxAngleStepSizeDegrees: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_G_GetCurveGeometry(
        hGeom: OGRGeometryH,
        papszOptions: *mut *mut libc::c_char,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGRBuildPolygonFromEdges(
        hLinesAsCollection: OGRGeometryH,
        bBestEffort: libc::c_int,
        bAutoClose: libc::c_int,
        dfTolerance: f64,
        peErr: *mut OGRErr::Type,
    ) -> OGRGeometryH;
}
extern "C" {
    pub fn OGRSetGenerate_DB2_V72_BYTE_ORDER(
        bGenerate_DB2_V72_BYTE_ORDER: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGRGetGenerate_DB2_V72_BYTE_ORDER() -> libc::c_int;
}
extern "C" {
    pub fn OGRSetNonLinearGeometriesEnabledFlag(bFlag: libc::c_int);
}
extern "C" {
    pub fn OGRGetNonLinearGeometriesEnabledFlag() -> libc::c_int;
}
pub type OGRFieldDefnH = *mut libc::c_void;
pub type OGRFeatureDefnH = *mut libc::c_void;
pub type OGRFeatureH = *mut libc::c_void;
pub type OGRStyleTableH = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OGRGeomFieldDefnHS {
    _unused: [u8; 0],
}
pub type OGRGeomFieldDefnH = *mut OGRGeomFieldDefnHS;
extern "C" {
    pub fn OGR_Fld_Create(arg1: *const libc::c_char, arg2: OGRFieldType::Type) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_Fld_Destroy(arg1: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_Fld_SetName(arg1: OGRFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_GetNameRef(arg1: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_GetType(arg1: OGRFieldDefnH) -> OGRFieldType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetType(arg1: OGRFieldDefnH, arg2: OGRFieldType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetSubType(arg1: OGRFieldDefnH) -> OGRFieldSubType::Type;
}
extern "C" {
    pub fn OGR_Fld_SetSubType(arg1: OGRFieldDefnH, arg2: OGRFieldSubType::Type);
}
extern "C" {
    pub fn OGR_Fld_GetJustify(arg1: OGRFieldDefnH) -> OGRJustification::Type;
}
extern "C" {
    pub fn OGR_Fld_SetJustify(arg1: OGRFieldDefnH, arg2: OGRJustification::Type);
}
extern "C" {
    pub fn OGR_Fld_GetWidth(arg1: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetWidth(arg1: OGRFieldDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetPrecision(arg1: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetPrecision(arg1: OGRFieldDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_Set(
        arg1: OGRFieldDefnH,
        arg2: *const libc::c_char,
        arg3: OGRFieldType::Type,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: OGRJustification::Type,
    );
}
extern "C" {
    pub fn OGR_Fld_IsIgnored(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetIgnored(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_IsNullable(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Fld_SetNullable(hDefn: OGRFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_Fld_GetDefault(hDefn: OGRFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Fld_SetDefault(hDefn: OGRFieldDefnH, arg1: *const libc::c_char);
}
extern "C" {
    pub fn OGR_Fld_IsDefaultDriverSpecific(hDefn: OGRFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GetFieldTypeName(arg1: OGRFieldType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_GetFieldSubTypeName(arg1: OGRFieldSubType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_AreTypeSubTypeCompatible(
        eType: OGRFieldType::Type,
        eSubType: OGRFieldSubType::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_Create(
        arg1: *const libc::c_char,
        arg2: OGRwkbGeometryType::Type,
    ) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_GFld_Destroy(arg1: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_GFld_SetName(arg1: OGRGeomFieldDefnH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_GFld_GetNameRef(arg1: OGRGeomFieldDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_GFld_GetType(arg1: OGRGeomFieldDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_GFld_SetType(arg1: OGRGeomFieldDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_GFld_GetSpatialRef(arg1: OGRGeomFieldDefnH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_GFld_SetSpatialRef(arg1: OGRGeomFieldDefnH, hSRS: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OGR_GFld_IsNullable(hDefn: OGRGeomFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetNullable(hDefn: OGRGeomFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_GFld_IsIgnored(hDefn: OGRGeomFieldDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_GFld_SetIgnored(hDefn: OGRGeomFieldDefnH, arg1: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_Create(arg1: *const libc::c_char) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_FD_Destroy(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_Release(arg1: OGRFeatureDefnH);
}
extern "C" {
    pub fn OGR_FD_GetName(arg1: OGRFeatureDefnH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_FD_GetFieldCount(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetFieldDefn(arg1: OGRFeatureDefnH, arg2: libc::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetFieldIndex(arg1: OGRFeatureDefnH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_AddFieldDefn(arg1: OGRFeatureDefnH, arg2: OGRFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteFieldDefn(hDefn: OGRFeatureDefnH, iField: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_ReorderFieldDefns(
        hDefn: OGRFeatureDefnH,
        panMap: *mut libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_GetGeomType(arg1: OGRFeatureDefnH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_FD_SetGeomType(arg1: OGRFeatureDefnH, arg2: OGRwkbGeometryType::Type);
}
extern "C" {
    pub fn OGR_FD_IsGeometryIgnored(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_SetGeometryIgnored(arg1: OGRFeatureDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_IsStyleIgnored(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_SetStyleIgnored(arg1: OGRFeatureDefnH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_FD_Reference(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_Dereference(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetReferenceCount(arg1: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldCount(hFDefn: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldDefn(hFDefn: OGRFeatureDefnH, i: libc::c_int) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_FD_GetGeomFieldIndex(
        hFDefn: OGRFeatureDefnH,
        pszName: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_FD_AddGeomFieldDefn(hFDefn: OGRFeatureDefnH, hGFldDefn: OGRGeomFieldDefnH);
}
extern "C" {
    pub fn OGR_FD_DeleteGeomFieldDefn(
        hFDefn: OGRFeatureDefnH,
        iGeomField: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_FD_IsSame(hFDefn: OGRFeatureDefnH, hOtherFDefn: OGRFeatureDefnH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_Create(arg1: OGRFeatureDefnH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Destroy(arg1: OGRFeatureH);
}
extern "C" {
    pub fn OGR_F_GetDefnRef(arg1: OGRFeatureH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_F_SetGeometryDirectly(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeometry(arg1: OGRFeatureH, arg2: OGRGeometryH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetGeometryRef(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_StealGeometry(arg1: OGRFeatureH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_Clone(arg1: OGRFeatureH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_F_Equal(arg1: OGRFeatureH, arg2: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldCount(arg1: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldDefnRef(arg1: OGRFeatureH, arg2: libc::c_int) -> OGRFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetFieldIndex(arg1: OGRFeatureH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_IsFieldSet(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_UnsetField(arg1: OGRFeatureH, arg2: libc::c_int);
}
extern "C" {
    pub fn OGR_F_GetRawFieldRef(arg1: OGRFeatureH, arg2: libc::c_int) -> *mut OGRField;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger(arg1: OGRFeatureH, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64(arg1: OGRFeatureH, arg2: libc::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDouble(arg1: OGRFeatureH, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsString(arg1: OGRFeatureH, arg2: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsIntegerList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsInteger64List(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const GIntBig;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDoubleList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *const f64;
}
extern "C" {
    pub fn OGR_F_GetFieldAsStringList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn OGR_F_GetFieldAsBinary(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut GByte;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTime(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
        arg9: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetFieldAsDateTimeEx(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        pnYear: *mut libc::c_int,
        pnMonth: *mut libc::c_int,
        pnDay: *mut libc::c_int,
        pnHour: *mut libc::c_int,
        pnMinute: *mut libc::c_int,
        pfSecond: *mut f32,
        pnTZFlag: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_SetFieldInteger(arg1: OGRFeatureH, arg2: libc::c_int, arg3: libc::c_int);
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64(arg1: OGRFeatureH, arg2: libc::c_int, arg3: GIntBig);
}
extern "C" {
    pub fn OGR_F_SetFieldDouble(arg1: OGRFeatureH, arg2: libc::c_int, arg3: f64);
}
extern "C" {
    pub fn OGR_F_SetFieldString(arg1: OGRFeatureH, arg2: libc::c_int, arg3: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_SetFieldIntegerList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldInteger64List(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const GIntBig,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDoubleList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut f64,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldStringList(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: *mut *mut libc::c_char,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldRaw(arg1: OGRFeatureH, arg2: libc::c_int, arg3: *mut OGRField);
}
extern "C" {
    pub fn OGR_F_SetFieldBinary(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut GByte,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTime(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_SetFieldDateTimeEx(
        arg1: OGRFeatureH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: f32,
        arg9: libc::c_int,
    );
}
extern "C" {
    pub fn OGR_F_GetGeomFieldCount(hFeat: OGRFeatureH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldDefnRef(hFeat: OGRFeatureH, iField: libc::c_int) -> OGRGeomFieldDefnH;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldIndex(hFeat: OGRFeatureH, pszName: *const libc::c_char)
        -> libc::c_int;
}
extern "C" {
    pub fn OGR_F_GetGeomFieldRef(hFeat: OGRFeatureH, iField: libc::c_int) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_F_SetGeomFieldDirectly(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetGeomField(
        hFeat: OGRFeatureH,
        iField: libc::c_int,
        hGeom: OGRGeometryH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetFID(arg1: OGRFeatureH) -> GIntBig;
}
extern "C" {
    pub fn OGR_F_SetFID(arg1: OGRFeatureH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_DumpReadable(arg1: OGRFeatureH, arg2: *mut FILE);
}
extern "C" {
    pub fn OGR_F_SetFrom(arg1: OGRFeatureH, arg2: OGRFeatureH, arg3: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_SetFromWithMap(
        arg1: OGRFeatureH,
        arg2: OGRFeatureH,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_F_GetStyleString(arg1: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_F_SetStyleString(arg1: OGRFeatureH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn OGR_F_SetStyleStringDirectly(arg1: OGRFeatureH, arg2: *mut libc::c_char);
}
extern "C" {
    pub fn OGR_F_GetStyleTable(arg1: OGRFeatureH) -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_F_SetStyleTableDirectly(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_F_SetStyleTable(arg1: OGRFeatureH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_F_FillUnsetWithDefault(
        hFeat: OGRFeatureH,
        bNotNullableOnly: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    );
}
extern "C" {
    pub fn OGR_F_Validate(
        arg1: OGRFeatureH,
        nValidateFlags: libc::c_int,
        bEmitError: libc::c_int,
    ) -> libc::c_int;
}
pub type OGRLayerH = *mut libc::c_void;
pub type OGRDataSourceH = *mut libc::c_void;
pub type OGRSFDriverH = *mut libc::c_void;
extern "C" {
    pub fn OGR_L_GetName(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeomType(arg1: OGRLayerH) -> OGRwkbGeometryType::Type;
}
extern "C" {
    pub fn OGR_L_GetSpatialFilter(arg1: OGRLayerH) -> OGRGeometryH;
}
extern "C" {
    pub fn OGR_L_SetSpatialFilter(arg1: OGRLayerH, arg2: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRect(arg1: OGRLayerH, arg2: f64, arg3: f64, arg4: f64, arg5: f64);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterEx(arg1: OGRLayerH, iGeomField: libc::c_int, hGeom: OGRGeometryH);
}
extern "C" {
    pub fn OGR_L_SetSpatialFilterRectEx(
        arg1: OGRLayerH,
        iGeomField: libc::c_int,
        dfMinX: f64,
        dfMinY: f64,
        dfMaxX: f64,
        dfMaxY: f64,
    );
}
extern "C" {
    pub fn OGR_L_SetAttributeFilter(arg1: OGRLayerH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ResetReading(arg1: OGRLayerH);
}
extern "C" {
    pub fn OGR_L_GetNextFeature(arg1: OGRLayerH) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetNextByIndex(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRFeatureH;
}
extern "C" {
    pub fn OGR_L_SetFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateFeature(arg1: OGRLayerH, arg2: OGRFeatureH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteFeature(arg1: OGRLayerH, arg2: GIntBig) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetLayerDefn(arg1: OGRLayerH) -> OGRFeatureDefnH;
}
extern "C" {
    pub fn OGR_L_GetSpatialRef(arg1: OGRLayerH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OGR_L_FindFieldIndex(
        arg1: OGRLayerH,
        arg2: *const libc::c_char,
        bExactMatch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_GetFeatureCount(arg1: OGRLayerH, arg2: libc::c_int) -> GIntBig;
}
extern "C" {
    pub fn OGR_L_GetExtent(
        arg1: OGRLayerH,
        arg2: *mut OGREnvelope,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetExtentEx(
        arg1: OGRLayerH,
        iGeomField: libc::c_int,
        psExtent: *mut OGREnvelope,
        bForce: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_TestCapability(arg1: OGRLayerH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_CreateField(
        arg1: OGRLayerH,
        arg2: OGRFieldDefnH,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CreateGeomField(
        hLayer: OGRLayerH,
        hFieldDefn: OGRGeomFieldDefnH,
        bForce: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_DeleteField(arg1: OGRLayerH, iField: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderFields(arg1: OGRLayerH, panMap: *mut libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_ReorderField(
        arg1: OGRLayerH,
        iOldFieldPos: libc::c_int,
        iNewFieldPos: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_AlterFieldDefn(
        arg1: OGRLayerH,
        iField: libc::c_int,
        hNewFieldDefn: OGRFieldDefnH,
        nFlags: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_StartTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_CommitTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_RollbackTransaction(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Reference(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_Dereference(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_GetRefCount(arg1: OGRLayerH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_L_SyncToDisk(arg1: OGRLayerH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_GetFeaturesRead(arg1: OGRLayerH) -> GIntBig;
}
extern "C" {
    pub fn OGR_L_GetFIDColumn(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetGeometryColumn(arg1: OGRLayerH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_L_GetStyleTable(arg1: OGRLayerH) -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_L_SetStyleTableDirectly(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_L_SetStyleTable(arg1: OGRLayerH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_L_SetIgnoredFields(arg1: OGRLayerH, arg2: *mut *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Intersection(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Union(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_SymDifference(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Identity(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Update(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Clip(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_L_Erase(
        arg1: OGRLayerH,
        arg2: OGRLayerH,
        arg3: OGRLayerH,
        arg4: *mut *mut libc::c_char,
        arg5: GDALProgressFunc,
        arg6: *mut libc::c_void,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_Destroy(arg1: OGRDataSourceH);
}
extern "C" {
    pub fn OGR_DS_GetName(arg1: OGRDataSourceH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_DS_GetLayerCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetLayer(arg1: OGRDataSourceH, arg2: libc::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_GetLayerByName(arg1: OGRDataSourceH, arg2: *const libc::c_char) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_DeleteLayer(arg1: OGRDataSourceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_GetDriver(arg1: OGRDataSourceH) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGR_DS_CreateLayer(
        arg1: OGRDataSourceH,
        arg2: *const libc::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_CopyLayer(
        arg1: OGRDataSourceH,
        arg2: OGRLayerH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_TestCapability(arg1: OGRDataSourceH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_ExecuteSQL(
        arg1: OGRDataSourceH,
        arg2: *const libc::c_char,
        arg3: OGRGeometryH,
        arg4: *const libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn OGR_DS_ReleaseResultSet(arg1: OGRDataSourceH, arg2: OGRLayerH);
}
extern "C" {
    pub fn OGR_DS_Reference(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_Dereference(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetRefCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_GetSummaryRefCount(arg1: OGRDataSourceH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_DS_SyncToDisk(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGR_DS_GetStyleTable(arg1: OGRDataSourceH) -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_DS_SetStyleTableDirectly(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_DS_SetStyleTable(arg1: OGRDataSourceH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_Dr_GetName(arg1: OGRSFDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_Dr_Open(
        arg1: OGRSFDriverH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_TestCapability(arg1: OGRSFDriverH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn OGR_Dr_CreateDataSource(
        arg1: OGRSFDriverH,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_CopyDataSource(
        arg1: OGRSFDriverH,
        arg2: OGRDataSourceH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGR_Dr_DeleteDataSource(arg1: OGRSFDriverH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OGROpen(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGROpenShared(
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: *mut OGRSFDriverH,
    ) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGRReleaseDataSource(arg1: OGRDataSourceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OGRRegisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    pub fn OGRDeregisterDriver(arg1: OGRSFDriverH);
}
extern "C" {
    pub fn OGRGetDriverCount() -> libc::c_int;
}
extern "C" {
    pub fn OGRGetDriver(arg1: libc::c_int) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGRGetDriverByName(arg1: *const libc::c_char) -> OGRSFDriverH;
}
extern "C" {
    pub fn OGRGetOpenDSCount() -> libc::c_int;
}
extern "C" {
    pub fn OGRGetOpenDS(iDS: libc::c_int) -> OGRDataSourceH;
}
extern "C" {
    pub fn OGRRegisterAll();
}
extern "C" {
    pub fn OGRCleanupAll();
}
pub type OGRStyleMgrH = *mut libc::c_void;
pub type OGRStyleToolH = *mut libc::c_void;
extern "C" {
    pub fn OGR_SM_Create(hStyleTable: OGRStyleTableH) -> OGRStyleMgrH;
}
extern "C" {
    pub fn OGR_SM_Destroy(hSM: OGRStyleMgrH);
}
extern "C" {
    pub fn OGR_SM_InitFromFeature(hSM: OGRStyleMgrH, hFeat: OGRFeatureH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_SM_InitStyleString(
        hSM: OGRStyleMgrH,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPartCount(
        hSM: OGRStyleMgrH,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_GetPart(
        hSM: OGRStyleMgrH,
        nPartId: libc::c_int,
        pszStyleString: *const libc::c_char,
    ) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_SM_AddPart(hSM: OGRStyleMgrH, hST: OGRStyleToolH) -> libc::c_int;
}
extern "C" {
    pub fn OGR_SM_AddStyle(
        hSM: OGRStyleMgrH,
        pszStyleName: *const libc::c_char,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_ST_Create(eClassId: OGRSTClassId) -> OGRStyleToolH;
}
extern "C" {
    pub fn OGR_ST_Destroy(hST: OGRStyleToolH);
}
extern "C" {
    pub fn OGR_ST_GetType(hST: OGRStyleToolH) -> OGRSTClassId;
}
extern "C" {
    pub fn OGR_ST_GetUnit(hST: OGRStyleToolH) -> OGRSTUnitId;
}
extern "C" {
    pub fn OGR_ST_SetUnit(hST: OGRStyleToolH, eUnit: OGRSTUnitId, dfGroundPaperScale: f64);
}
extern "C" {
    pub fn OGR_ST_GetParamStr(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_ST_GetParamNum(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_ST_GetParamDbl(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        bValueIsNull: *mut libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn OGR_ST_SetParamStr(
        hST: OGRStyleToolH,
        eParam: libc::c_int,
        pszValue: *const libc::c_char,
    );
}
extern "C" {
    pub fn OGR_ST_SetParamNum(hST: OGRStyleToolH, eParam: libc::c_int, nValue: libc::c_int);
}
extern "C" {
    pub fn OGR_ST_SetParamDbl(hST: OGRStyleToolH, eParam: libc::c_int, dfValue: f64);
}
extern "C" {
    pub fn OGR_ST_GetStyleString(hST: OGRStyleToolH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_ST_GetRGBFromString(
        hST: OGRStyleToolH,
        pszColor: *const libc::c_char,
        pnRed: *mut libc::c_int,
        pnGreen: *mut libc::c_int,
        pnBlue: *mut libc::c_int,
        pnAlpha: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_Create() -> OGRStyleTableH;
}
extern "C" {
    pub fn OGR_STBL_Destroy(hSTBL: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_AddStyle(
        hStyleTable: OGRStyleTableH,
        pszName: *const libc::c_char,
        pszStyleString: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_SaveStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_LoadStyleTable(
        hStyleTable: OGRStyleTableH,
        pszFilename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OGR_STBL_Find(
        hStyleTable: OGRStyleTableH,
        pszName: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_STBL_ResetStyleStringReading(hStyleTable: OGRStyleTableH);
}
extern "C" {
    pub fn OGR_STBL_GetNextStyle(hStyleTable: OGRStyleTableH) -> *const libc::c_char;
}
extern "C" {
    pub fn OGR_STBL_GetLastStyleName(hStyleTable: OGRStyleTableH) -> *const libc::c_char;
}
pub mod GDALDataType {
    /// Pixel data types
    pub type Type = u32;
    /// Unknown or unspecified type
    pub const GDT_Unknown: Type = 0;
    /// Eight bit unsigned integer
    pub const GDT_Byte: Type = 1;
    /// Sixteen bit unsigned integer
    pub const GDT_UInt16: Type = 2;
    /// Sixteen bit signed integer
    pub const GDT_Int16: Type = 3;
    /// Thirty two bit unsigned integer
    pub const GDT_UInt32: Type = 4;
    /// Thirty two bit signed integer
    pub const GDT_Int32: Type = 5;
    /// Thirty two bit floating point
    pub const GDT_Float32: Type = 6;
    /// Sixty four bit floating point
    pub const GDT_Float64: Type = 7;
    /// Complex Int16
    pub const GDT_CInt16: Type = 8;
    /// Complex Int32
    pub const GDT_CInt32: Type = 9;
    /// Complex Float32
    pub const GDT_CFloat32: Type = 10;
    /// Complex Float64
    pub const GDT_CFloat64: Type = 11;
    /// Complex Float64
    pub const GDT_TypeCount: Type = 12;
}
extern "C" {
    pub fn GDALGetDataTypeSize(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALDataTypeIsComplex(arg1: GDALDataType::Type) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDataTypeName(arg1: GDALDataType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDataTypeByName(arg1: *const libc::c_char) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALDataTypeUnion(
        arg1: GDALDataType::Type,
        arg2: GDALDataType::Type,
    ) -> GDALDataType::Type;
}
pub mod GDALAsyncStatusType {
    /// status of the asynchronous stream
    pub type Type = u32;
    pub const GARIO_PENDING: Type = 0;
    pub const GARIO_UPDATE: Type = 1;
    pub const GARIO_ERROR: Type = 2;
    pub const GARIO_COMPLETE: Type = 3;
    pub const GARIO_TypeCount: Type = 4;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeName(arg1: GDALAsyncStatusType::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetAsyncStatusTypeByName(arg1: *const libc::c_char) -> GDALAsyncStatusType::Type;
}
pub mod GDALAccess {
    /// Flag indicating read/write, or read-only access to data.
    pub type Type = u32;
    /// Read only (no update) access
    pub const GA_ReadOnly: Type = 0;
    /// Read/write access.
    pub const GA_Update: Type = 1;
}
pub mod GDALRWFlag {
    /// Read/Write flag for RasterIO() method
    pub type Type = u32;
    /// Read data
    pub const GF_Read: Type = 0;
    /// Write data
    pub const GF_Write: Type = 1;
}
pub mod GDALRIOResampleAlg {
    /// RasterIO() resampling method.
    /// @since GDAL 2.0
    pub type Type = u32;
    /// Nearest neighbour
    pub const GRIORA_NearestNeighbour: Type = 0;
    /// Bilinear (2x2 kernel)
    pub const GRIORA_Bilinear: Type = 1;
    /// Cubic Convolution Approximation (4x4 kernel)
    pub const GRIORA_Cubic: Type = 2;
    /// Cubic B-Spline Approximation (4x4 kernel)
    pub const GRIORA_CubicSpline: Type = 3;
    /// Lanczos windowed sinc interpolation (6x6 kernel)
    pub const GRIORA_Lanczos: Type = 4;
    /// Average
    pub const GRIORA_Average: Type = 5;
    /// Mode (selects the value which appears most often of all the sampled points)
    pub const GRIORA_Mode: Type = 6;
    /// Gauss blurring
    pub const GRIORA_Gauss: Type = 7;
}
/// Structure to pass extra arguments to RasterIO() method
/// @since GDAL 2.0
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRasterIOExtraArg {
    /// Version of structure (to allow future extensions of the structure)
    pub nVersion: libc::c_int,
    /// Resampling algorithm
    pub eResampleAlg: GDALRIOResampleAlg::Type,
    /// Progress callback
    pub pfnProgress: GDALProgressFunc,
    /// Progress callback user data
    pub pProgressData: *mut libc::c_void,
    /// Indicate if dfXOff, dfYOff, dfXSize and dfYSize are set.
    /// Mostly reserved from the VRT driver to communicate a more precise
    /// source window. Must be such that dfXOff - nXOff < 1.0 and
    /// dfYOff - nYOff < 1.0 and nXSize - dfXSize < 1.0 and nYSize - dfYSize < 1.0
    pub bFloatingPointWindowValidity: libc::c_int,
    /// Pixel offset to the top left corner. Only valid if bFloatingPointWindowValidity = TRUE
    pub dfXOff: f64,
    /// Line offset to the top left corner. Only valid if bFloatingPointWindowValidity = TRUE
    pub dfYOff: f64,
    /// Width in pixels of the area of interest. Only valid if bFloatingPointWindowValidity = TRUE
    pub dfXSize: f64,
    /// Height in pixels of the area of interest. Only valid if bFloatingPointWindowValidity = TRUE
    pub dfYSize: f64,
}
#[test]
fn bindgen_test_layout_GDALRasterIOExtraArg() {
    assert_eq!(
        ::std::mem::size_of::<GDALRasterIOExtraArg>(),
        64usize,
        concat!("Size of: ", stringify!(GDALRasterIOExtraArg))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRasterIOExtraArg>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRasterIOExtraArg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).nVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(nVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).eResampleAlg as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(eResampleAlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).pfnProgress as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(pfnProgress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).pProgressData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(pProgressData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).bFloatingPointWindowValidity
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(bFloatingPointWindowValidity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfXOff as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfXOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfYOff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfYOff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfXSize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfXSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRasterIOExtraArg>())).dfYSize as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRasterIOExtraArg),
            "::",
            stringify!(dfYSize)
        )
    );
}
pub mod GDALColorInterp {
    /// Types of color interpretation for raster bands.
    pub type Type = u32;
    pub const GCI_Undefined: Type = 0;
    /// Greyscale
    pub const GCI_GrayIndex: Type = 1;
    /// Paletted (see associated color table)
    pub const GCI_PaletteIndex: Type = 2;
    /// Red band of RGBA image
    pub const GCI_RedBand: Type = 3;
    /// Green band of RGBA image
    pub const GCI_GreenBand: Type = 4;
    /// Blue band of RGBA image
    pub const GCI_BlueBand: Type = 5;
    /// Alpha (0=transparent, 255=opaque)
    pub const GCI_AlphaBand: Type = 6;
    /// Hue band of HLS image
    pub const GCI_HueBand: Type = 7;
    /// Saturation band of HLS image
    pub const GCI_SaturationBand: Type = 8;
    /// Lightness band of HLS image
    pub const GCI_LightnessBand: Type = 9;
    /// Cyan band of CMYK image
    pub const GCI_CyanBand: Type = 10;
    /// Magenta band of CMYK image
    pub const GCI_MagentaBand: Type = 11;
    /// Yellow band of CMYK image
    pub const GCI_YellowBand: Type = 12;
    /// Black band of CMLY image
    pub const GCI_BlackBand: Type = 13;
    /// Y Luminance
    pub const GCI_YCbCr_YBand: Type = 14;
    /// Cb Chroma
    pub const GCI_YCbCr_CbBand: Type = 15;
    /// Cr Chroma
    pub const GCI_YCbCr_CrBand: Type = 16;
    /// Max current value
    pub const GCI_Max: Type = 16;
}
extern "C" {
    pub fn GDALGetColorInterpretationName(arg1: GDALColorInterp::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetColorInterpretationByName(pszName: *const libc::c_char) -> GDALColorInterp::Type;
}
pub mod GDALPaletteInterp {
    /// Types of color interpretations for a GDALColorTable.
    pub type Type = u32;
    /// Grayscale (in GDALColorEntry.c1)
    pub const GPI_Gray: Type = 0;
    /// Red, Green, Blue and Alpha in (in c1, c2, c3 and c4)
    pub const GPI_RGB: Type = 1;
    /// Cyan, Magenta, Yellow and Black (in c1, c2, c3 and c4)
    pub const GPI_CMYK: Type = 2;
    /// Hue, Lightness and Saturation (in c1, c2, and c3)
    pub const GPI_HLS: Type = 3;
}
extern "C" {
    pub fn GDALGetPaletteInterpretationName(arg1: GDALPaletteInterp::Type) -> *const libc::c_char;
}
/// Opaque type used for the C bindings of the C++ GDALMajorObject class
pub type GDALMajorObjectH = *mut libc::c_void;
/// Opaque type used for the C bindings of the C++ GDALDataset class
pub type GDALDatasetH = *mut libc::c_void;
/// Opaque type used for the C bindings of the C++ GDALRasterBand class
pub type GDALRasterBandH = *mut libc::c_void;
/// Opaque type used for the C bindings of the C++ GDALDriver class
pub type GDALDriverH = *mut libc::c_void;
/// Opaque type used for the C bindings of the C++ GDALColorTable class
pub type GDALColorTableH = *mut libc::c_void;
/// Opaque type used for the C bindings of the C++ GDALRasterAttributeTable class
pub type GDALRasterAttributeTableH = *mut libc::c_void;
/// Opaque type used for the C bindings of the C++ GDALAsyncReader class
pub type GDALAsyncReaderH = *mut libc::c_void;
/// Type to express pixel, line or band spacing. Signed 64 bit integer.
pub type GSpacing = GIntBig;
extern "C" {
    pub fn GDALAllRegister();
}
extern "C" {
    pub fn GDALCreate(
        hDriver: GDALDriverH,
        arg1: *const libc::c_char,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: GDALDataType::Type,
        arg6: *mut *mut libc::c_char,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateCopy(
        arg1: GDALDriverH,
        arg2: *const libc::c_char,
        arg3: GDALDatasetH,
        arg4: libc::c_int,
        arg5: *mut *mut libc::c_char,
        arg6: GDALProgressFunc,
        arg7: *mut libc::c_void,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALIdentifyDriver(
        pszFilename: *const libc::c_char,
        papszFileList: *mut *mut libc::c_char,
    ) -> GDALDriverH;
}
extern "C" {
    pub fn GDALOpen(pszFilename: *const libc::c_char, eAccess: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenShared(arg1: *const libc::c_char, arg2: GDALAccess::Type) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALOpenEx(
        pszFilename: *const libc::c_char,
        nOpenFlags: libc::c_uint,
        papszAllowedDrivers: *const *const libc::c_char,
        papszOpenOptions: *const *const libc::c_char,
        papszSiblingFiles: *const *const libc::c_char,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALDumpOpenDatasets(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriverByName(arg1: *const libc::c_char) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetDriverCount() -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriver(arg1: libc::c_int) -> GDALDriverH;
}
extern "C" {
    pub fn GDALDestroyDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALRegisterDriver(arg1: GDALDriverH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDeregisterDriver(arg1: GDALDriverH);
}
extern "C" {
    pub fn GDALDestroyDriverManager();
}
extern "C" {
    pub fn GDALDestroy();
}
extern "C" {
    pub fn GDALDeleteDataset(arg1: GDALDriverH, arg2: *const libc::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRenameDataset(
        arg1: GDALDriverH,
        pszNewName: *const libc::c_char,
        pszOldName: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCopyDatasetFiles(
        arg1: GDALDriverH,
        pszNewName: *const libc::c_char,
        pszOldName: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALValidateCreationOptions(
        arg1: GDALDriverH,
        papszCreationOptions: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetDriverShortName(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverLongName(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverHelpTopic(arg1: GDALDriverH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetDriverCreationOptionList(arg1: GDALDriverH) -> *const libc::c_char;
}
/// Ground Control Point
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDAL_GCP {
    /// Unique identifier, often numeric
    pub pszId: *mut libc::c_char,
    /// Informational message or ""
    pub pszInfo: *mut libc::c_char,
    /// Pixel (x) location of GCP on raster
    pub dfGCPPixel: f64,
    /// Line (y) location of GCP on raster
    pub dfGCPLine: f64,
    /// X position of GCP in georeferenced space
    pub dfGCPX: f64,
    /// Y position of GCP in georeferenced space
    pub dfGCPY: f64,
    /// Elevation of GCP, or zero if not known
    pub dfGCPZ: f64,
}
#[test]
fn bindgen_test_layout_GDAL_GCP() {
    assert_eq!(
        ::std::mem::size_of::<GDAL_GCP>(),
        56usize,
        concat!("Size of: ", stringify!(GDAL_GCP))
    );
    assert_eq!(
        ::std::mem::align_of::<GDAL_GCP>(),
        8usize,
        concat!("Alignment of ", stringify!(GDAL_GCP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).pszId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(pszId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).pszInfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(pszInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPPixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPPixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPLine as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPLine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPX as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPY as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDAL_GCP>())).dfGCPZ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDAL_GCP),
            "::",
            stringify!(dfGCPZ)
        )
    );
}
extern "C" {
    pub fn GDALInitGCPs(arg1: libc::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDeinitGCPs(arg1: libc::c_int, arg2: *mut GDAL_GCP);
}
extern "C" {
    pub fn GDALDuplicateGCPs(arg1: libc::c_int, arg2: *const GDAL_GCP) -> *mut GDAL_GCP;
}
extern "C" {
    pub fn GDALGCPsToGeoTransform(
        nGCPCount: libc::c_int,
        pasGCPs: *const GDAL_GCP,
        padfGeoTransform: *mut f64,
        bApproxOK: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALInvGeoTransform(
        padfGeoTransformIn: *mut f64,
        padfInvGeoTransformOut: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALApplyGeoTransform(
        arg1: *mut f64,
        arg2: f64,
        arg3: f64,
        arg4: *mut f64,
        arg5: *mut f64,
    );
}
extern "C" {
    pub fn GDALComposeGeoTransforms(
        padfGeoTransform1: *const f64,
        padfGeoTransform2: *const f64,
        padfGeoTransformOut: *mut f64,
    );
}
extern "C" {
    pub fn GDALGetMetadataDomainList(hObject: GDALMajorObjectH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALGetMetadata(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALSetMetadata(
        arg1: GDALMajorObjectH,
        arg2: *mut *mut libc::c_char,
        arg3: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetMetadataItem(
        arg1: GDALMajorObjectH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDescription(arg1: GDALMajorObjectH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetDescription(arg1: GDALMajorObjectH, arg2: *const libc::c_char);
}
extern "C" {
    pub fn GDALGetDatasetDriver(arg1: GDALDatasetH) -> GDALDriverH;
}
extern "C" {
    pub fn GDALGetFileList(arg1: GDALDatasetH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALClose(arg1: GDALDatasetH);
}
extern "C" {
    pub fn GDALGetRasterXSize(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterYSize(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterBand(arg1: GDALDatasetH, arg2: libc::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALAddBand(
        hDS: GDALDatasetH,
        eType: GDALDataType::Type,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALBeginAsyncReader(
        hDS: GDALDatasetH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        pBuf: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nBandSpace: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> GDALAsyncReaderH;
}
extern "C" {
    pub fn GDALEndAsyncReader(hDS: GDALDatasetH, hAsynchReaderH: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALDatasetRasterIO(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nBandSpace: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetRasterIOEx(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        nBandSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetAdviseRead(
        hDS: GDALDatasetH,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandCount: *mut libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetProjectionRef(arg1: GDALDatasetH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetProjection(arg1: GDALDatasetH, arg2: *const libc::c_char) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetGeoTransform(arg1: GDALDatasetH, arg2: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetGCPCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetGCPProjection(arg1: GDALDatasetH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALGetGCPs(arg1: GDALDatasetH) -> *const GDAL_GCP;
}
extern "C" {
    pub fn GDALSetGCPs(
        arg1: GDALDatasetH,
        arg2: libc::c_int,
        arg3: *const GDAL_GCP,
        arg4: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetInternalHandle(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALReferenceDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDereferenceDataset(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALBuildOverviews(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_int,
        arg7: GDALProgressFunc,
        arg8: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetOpenDatasets(hDS: *mut *mut GDALDatasetH, pnCount: *mut libc::c_int);
}
extern "C" {
    pub fn GDALGetAccess(hDS: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALFlushCache(hDS: GDALDatasetH);
}
extern "C" {
    pub fn GDALCreateDatasetMaskBand(hDS: GDALDatasetH, nFlags: libc::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetCopyWholeRaster(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterBandCopyWholeRaster(
        hSrcBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRegenerateOverviews(
        hSrcBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviewBands: *mut GDALRasterBandH,
        pszResampling: *const libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALDatasetGetLayerCount(arg1: GDALDatasetH) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetGetLayer(arg1: GDALDatasetH, arg2: libc::c_int) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetGetLayerByName(arg1: GDALDatasetH, arg2: *const libc::c_char) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetDeleteLayer(arg1: GDALDatasetH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCreateLayer(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: OGRSpatialReferenceH,
        arg4: OGRwkbGeometryType::Type,
        arg5: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetCopyLayer(
        arg1: GDALDatasetH,
        arg2: OGRLayerH,
        arg3: *const libc::c_char,
        arg4: *mut *mut libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetTestCapability(arg1: GDALDatasetH, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetExecuteSQL(
        arg1: GDALDatasetH,
        arg2: *const libc::c_char,
        arg3: OGRGeometryH,
        arg4: *const libc::c_char,
    ) -> OGRLayerH;
}
extern "C" {
    pub fn GDALDatasetReleaseResultSet(arg1: GDALDatasetH, arg2: OGRLayerH);
}
extern "C" {
    pub fn GDALDatasetGetStyleTable(arg1: GDALDatasetH) -> OGRStyleTableH;
}
extern "C" {
    pub fn GDALDatasetSetStyleTableDirectly(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetSetStyleTable(arg1: GDALDatasetH, arg2: OGRStyleTableH);
}
extern "C" {
    pub fn GDALDatasetStartTransaction(hDS: GDALDatasetH, bForce: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetCommitTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
extern "C" {
    pub fn GDALDatasetRollbackTransaction(hDS: GDALDatasetH) -> OGRErr::Type;
}
pub type GDALDerivedPixelFunc = ::std::option::Option<
    unsafe extern "C" fn(
        papoSources: *mut *mut libc::c_void,
        nSources: libc::c_int,
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eSrcType: GDALDataType::Type,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
    ) -> CPLErr::Type,
>;
extern "C" {
    pub fn GDALGetRasterDataType(arg1: GDALRasterBandH) -> GDALDataType::Type;
}
extern "C" {
    pub fn GDALGetBlockSize(
        arg1: GDALRasterBandH,
        pnXSize: *mut libc::c_int,
        pnYSize: *mut libc::c_int,
    );
}
extern "C" {
    pub fn GDALRasterAdviseRead(
        hRB: GDALRasterBandH,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIO(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterIOEx(
        hRBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nDSXOff: libc::c_int,
        nDSYOff: libc::c_int,
        nDSXSize: libc::c_int,
        nDSYSize: libc::c_int,
        pBuffer: *mut libc::c_void,
        nBXSize: libc::c_int,
        nBYSize: libc::c_int,
        eBDataType: GDALDataType::Type,
        nPixelSpace: GSpacing,
        nLineSpace: GSpacing,
        psExtraArg: *mut GDALRasterIOExtraArg,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALReadBlock(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWriteBlock(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterBandXSize(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterBandYSize(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterAccess(arg1: GDALRasterBandH) -> GDALAccess::Type;
}
extern "C" {
    pub fn GDALGetBandNumber(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetBandDataset(arg1: GDALRasterBandH) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALGetRasterColorInterpretation(arg1: GDALRasterBandH) -> GDALColorInterp::Type;
}
extern "C" {
    pub fn GDALSetRasterColorInterpretation(
        arg1: GDALRasterBandH,
        arg2: GDALColorInterp::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterColorTable(arg1: GDALRasterBandH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALSetRasterColorTable(arg1: GDALRasterBandH, arg2: GDALColorTableH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALHasArbitraryOverviews(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetOverviewCount(arg1: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetOverview(arg1: GDALRasterBandH, arg2: libc::c_int) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterNoDataValue(arg1: GDALRasterBandH, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterNoDataValue(arg1: GDALRasterBandH, arg2: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterCategoryNames(arg1: GDALRasterBandH) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn GDALSetRasterCategoryNames(
        arg1: GDALRasterBandH,
        arg2: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterMinimum(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterMaximum(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALGetRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: libc::c_int,
        bForce: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterStatistics(
        arg1: GDALRasterBandH,
        bApproxOK: libc::c_int,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetRasterStatistics(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        dfMean: f64,
        dfStdDev: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterUnitType(arg1: GDALRasterBandH) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALSetRasterUnitType(
        hBand: GDALRasterBandH,
        pszNewValue: *const libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterOffset(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterOffset(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterScale(arg1: GDALRasterBandH, pbSuccess: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn GDALSetRasterScale(hBand: GDALRasterBandH, dfNewOffset: f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeRasterMinMax(
        hBand: GDALRasterBandH,
        bApproxOK: libc::c_int,
        adfMinMax: *mut f64,
    );
}
extern "C" {
    pub fn GDALFlushRasterCache(hBand: GDALRasterBandH) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut libc::c_int,
        bIncludeOutOfRange: libc::c_int,
        bApproxOK: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRasterHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut GUIntBig,
        bIncludeOutOfRange: libc::c_int,
        bApproxOK: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogram(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut libc::c_int,
        ppanHistogram: *mut *mut libc::c_int,
        bForce: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        pdfMin: *mut f64,
        pdfMax: *mut f64,
        pnBuckets: *mut libc::c_int,
        ppanHistogram: *mut *mut GUIntBig,
        bForce: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogram(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSetDefaultHistogramEx(
        hBand: GDALRasterBandH,
        dfMin: f64,
        dfMax: f64,
        nBuckets: libc::c_int,
        panHistogram: *mut GUIntBig,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetRandomRasterSample(
        arg1: GDALRasterBandH,
        arg2: libc::c_int,
        arg3: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetRasterSampleOverview(arg1: GDALRasterBandH, arg2: libc::c_int)
        -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetRasterSampleOverviewEx(arg1: GDALRasterBandH, arg2: GUIntBig) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALFillRaster(
        hBand: GDALRasterBandH,
        dfRealValue: f64,
        dfImaginaryValue: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeBandStats(
        hBand: GDALRasterBandH,
        nSampleStep: libc::c_int,
        pdfMean: *mut f64,
        pdfStdDev: *mut f64,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALOverviewMagnitudeCorrection(
        hBaseBand: GDALRasterBandH,
        nOverviewCount: libc::c_int,
        pahOverviews: *mut GDALRasterBandH,
        pfnProgress: GDALProgressFunc,
        pProgressData: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetDefaultRAT(hBand: GDALRasterBandH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALSetDefaultRAT(
        arg1: GDALRasterBandH,
        arg2: GDALRasterAttributeTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALAddDerivedBandPixelFunc(
        pszName: *const libc::c_char,
        pfnPixelFunc: GDALDerivedPixelFunc,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALGetMaskBand(hBand: GDALRasterBandH) -> GDALRasterBandH;
}
extern "C" {
    pub fn GDALGetMaskFlags(hBand: GDALRasterBandH) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateMaskBand(hBand: GDALRasterBandH, nFlags: libc::c_int) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALARGetNextUpdatedRegion(
        hARIO: GDALAsyncReaderH,
        dfTimeout: f64,
        pnXBufOff: *mut libc::c_int,
        pnYBufOff: *mut libc::c_int,
        pnXBufSize: *mut libc::c_int,
        pnYBufSize: *mut libc::c_int,
    ) -> GDALAsyncStatusType::Type;
}
extern "C" {
    pub fn GDALARLockBuffer(hARIO: GDALAsyncReaderH, dfTimeout: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALARUnlockBuffer(hARIO: GDALAsyncReaderH);
}
extern "C" {
    pub fn GDALGeneralCmdLineProcessor(
        nArgc: libc::c_int,
        ppapszArgv: *mut *mut *mut libc::c_char,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSwapWords(
        pData: *mut libc::c_void,
        nWordSize: libc::c_int,
        nWordCount: libc::c_int,
        nWordSkip: libc::c_int,
    );
}
extern "C" {
    pub fn GDALCopyWords(
        pSrcData: *mut libc::c_void,
        eSrcType: GDALDataType::Type,
        nSrcPixelOffset: libc::c_int,
        pDstData: *mut libc::c_void,
        eDstType: GDALDataType::Type,
        nDstPixelOffset: libc::c_int,
        nWordCount: libc::c_int,
    );
}
extern "C" {
    pub fn GDALCopyBits(
        pabySrcData: *const GByte,
        nSrcOffset: libc::c_int,
        nSrcStep: libc::c_int,
        pabyDstData: *mut GByte,
        nDstOffset: libc::c_int,
        nDstStep: libc::c_int,
        nBitCount: libc::c_int,
        nStepCount: libc::c_int,
    );
}
extern "C" {
    pub fn GDALLoadWorldFile(arg1: *const libc::c_char, arg2: *mut f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadWorldFile(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALWriteWorldFile(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALLoadTabFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadTabFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALLoadOziMapFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALReadOziMapFile(
        arg1: *const libc::c_char,
        arg2: *mut f64,
        arg3: *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut GDAL_GCP,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDecToDMS(
        arg1: f64,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALPackedDMSToDec(arg1: f64) -> f64;
}
extern "C" {
    pub fn GDALDecToPackedDMS(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALRPCInfo {
    pub dfLINE_OFF: f64,
    pub dfSAMP_OFF: f64,
    pub dfLAT_OFF: f64,
    pub dfLONG_OFF: f64,
    pub dfHEIGHT_OFF: f64,
    pub dfLINE_SCALE: f64,
    pub dfSAMP_SCALE: f64,
    pub dfLAT_SCALE: f64,
    pub dfLONG_SCALE: f64,
    pub dfHEIGHT_SCALE: f64,
    pub adfLINE_NUM_COEFF: [f64; 20usize],
    pub adfLINE_DEN_COEFF: [f64; 20usize],
    pub adfSAMP_NUM_COEFF: [f64; 20usize],
    pub adfSAMP_DEN_COEFF: [f64; 20usize],
    pub dfMIN_LONG: f64,
    pub dfMIN_LAT: f64,
    pub dfMAX_LONG: f64,
    pub dfMAX_LAT: f64,
}
#[test]
fn bindgen_test_layout_GDALRPCInfo() {
    assert_eq!(
        ::std::mem::size_of::<GDALRPCInfo>(),
        752usize,
        concat!("Size of: ", stringify!(GDALRPCInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALRPCInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALRPCInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLINE_OFF as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLINE_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfSAMP_OFF as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfSAMP_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLAT_OFF as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLAT_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLONG_OFF as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLONG_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfHEIGHT_OFF as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfHEIGHT_OFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLINE_SCALE as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLINE_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfSAMP_SCALE as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfSAMP_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLAT_SCALE as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLAT_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfLONG_SCALE as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfLONG_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfHEIGHT_SCALE as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfHEIGHT_SCALE)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfLINE_NUM_COEFF as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfLINE_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfLINE_DEN_COEFF as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfLINE_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfSAMP_NUM_COEFF as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfSAMP_NUM_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).adfSAMP_DEN_COEFF as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(adfSAMP_DEN_COEFF)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMIN_LONG as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMIN_LONG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMIN_LAT as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMIN_LAT)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMAX_LONG as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMAX_LONG)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALRPCInfo>())).dfMAX_LAT as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALRPCInfo),
            "::",
            stringify!(dfMAX_LAT)
        )
    );
}
extern "C" {
    pub fn GDALExtractRPCInfo(arg1: *mut *mut libc::c_char, arg2: *mut GDALRPCInfo) -> libc::c_int;
}
/// Color tuple
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALColorEntry {
    /// gray, red, cyan or hue
    pub c1: libc::c_short,
    /// green, magenta, or lightness
    pub c2: libc::c_short,
    /// blue, yellow, or saturation
    pub c3: libc::c_short,
    /// alpha or blackband
    pub c4: libc::c_short,
}
#[test]
fn bindgen_test_layout_GDALColorEntry() {
    assert_eq!(
        ::std::mem::size_of::<GDALColorEntry>(),
        8usize,
        concat!("Size of: ", stringify!(GDALColorEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALColorEntry>(),
        2usize,
        concat!("Alignment of ", stringify!(GDALColorEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c3 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALColorEntry>())).c4 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALColorEntry),
            "::",
            stringify!(c4)
        )
    );
}
extern "C" {
    pub fn GDALCreateColorTable(arg1: GDALPaletteInterp::Type) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALDestroyColorTable(arg1: GDALColorTableH);
}
extern "C" {
    pub fn GDALCloneColorTable(arg1: GDALColorTableH) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALGetPaletteInterpretation(arg1: GDALColorTableH) -> GDALPaletteInterp::Type;
}
extern "C" {
    pub fn GDALGetColorEntryCount(arg1: GDALColorTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALGetColorEntry(arg1: GDALColorTableH, arg2: libc::c_int) -> *const GDALColorEntry;
}
extern "C" {
    pub fn GDALGetColorEntryAsRGB(
        arg1: GDALColorTableH,
        arg2: libc::c_int,
        arg3: *mut GDALColorEntry,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetColorEntry(arg1: GDALColorTableH, arg2: libc::c_int, arg3: *const GDALColorEntry);
}
extern "C" {
    pub fn GDALCreateColorRamp(
        hTable: GDALColorTableH,
        nStartIndex: libc::c_int,
        psStartColor: *const GDALColorEntry,
        nEndIndex: libc::c_int,
        psEndColor: *const GDALColorEntry,
    );
}
pub mod GDALRATFieldType {
    /// Field type of raster attribute table
    pub type Type = u32;
    /// Integer field
    pub const GFT_Integer: Type = 0;
    /// Floating point (double) field
    pub const GFT_Real: Type = 1;
    /// String field
    pub const GFT_String: Type = 2;
}
pub mod GDALRATFieldUsage {
    /// Field usage of raster attribute table
    pub type Type = u32;
    /// General purpose field.
    pub const GFU_Generic: Type = 0;
    /// Histogram pixel count
    pub const GFU_PixelCount: Type = 1;
    /// Class name
    pub const GFU_Name: Type = 2;
    /// Class range minimum
    pub const GFU_Min: Type = 3;
    /// Class range maximum
    pub const GFU_Max: Type = 4;
    /// Class value (min=max)
    pub const GFU_MinMax: Type = 5;
    /// Red class color (0-255)
    pub const GFU_Red: Type = 6;
    /// Green class color (0-255)
    pub const GFU_Green: Type = 7;
    /// Blue class color (0-255)
    pub const GFU_Blue: Type = 8;
    /// Alpha (0=transparent,255=opaque)
    pub const GFU_Alpha: Type = 9;
    /// Color Range Red Minimum
    pub const GFU_RedMin: Type = 10;
    /// Color Range Green Minimum
    pub const GFU_GreenMin: Type = 11;
    /// Color Range Blue Minimum
    pub const GFU_BlueMin: Type = 12;
    /// Color Range Alpha Minimum
    pub const GFU_AlphaMin: Type = 13;
    /// Color Range Red Maximum
    pub const GFU_RedMax: Type = 14;
    /// Color Range Green Maximum
    pub const GFU_GreenMax: Type = 15;
    /// Color Range Blue Maximum
    pub const GFU_BlueMax: Type = 16;
    /// Color Range Alpha Maximum
    pub const GFU_AlphaMax: Type = 17;
    /// Maximum GFU value
    pub const GFU_MaxCount: Type = 18;
}
extern "C" {
    pub fn GDALCreateRasterAttributeTable() -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALDestroyRasterAttributeTable(arg1: GDALRasterAttributeTableH);
}
extern "C" {
    pub fn GDALRATGetColumnCount(arg1: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetNameOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRATGetUsageOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> GDALRATFieldUsage::Type;
}
extern "C" {
    pub fn GDALRATGetTypeOfCol(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
    ) -> GDALRATFieldType::Type;
}
extern "C" {
    pub fn GDALRATGetColOfUsage(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALRATFieldUsage::Type,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetRowCount(arg1: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn GDALRATGetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATGetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GDALRATSetValueAsString(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsInt(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
    );
}
extern "C" {
    pub fn GDALRATSetValueAsDouble(
        arg1: GDALRasterAttributeTableH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: f64,
    );
}
extern "C" {
    pub fn GDALRATChangesAreWrittenToFile(hRAT: GDALRasterAttributeTableH) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATValuesIOAsDouble(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        pdfData: *mut f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsInteger(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        pnData: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATValuesIOAsString(
        hRAT: GDALRasterAttributeTableH,
        eRWFlag: GDALRWFlag::Type,
        iField: libc::c_int,
        iStartRow: libc::c_int,
        iLength: libc::c_int,
        papszStrList: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetRowCount(arg1: GDALRasterAttributeTableH, arg2: libc::c_int);
}
extern "C" {
    pub fn GDALRATCreateColumn(
        arg1: GDALRasterAttributeTableH,
        arg2: *const libc::c_char,
        arg3: GDALRATFieldType::Type,
        arg4: GDALRATFieldUsage::Type,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATSetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: f64,
        arg3: f64,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATGetLinearBinning(
        arg1: GDALRasterAttributeTableH,
        arg2: *mut f64,
        arg3: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALRATInitializeFromColorTable(
        arg1: GDALRasterAttributeTableH,
        arg2: GDALColorTableH,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRATTranslateToColorTable(
        arg1: GDALRasterAttributeTableH,
        nEntryCount: libc::c_int,
    ) -> GDALColorTableH;
}
extern "C" {
    pub fn GDALRATDumpReadable(arg1: GDALRasterAttributeTableH, arg2: *mut FILE);
}
extern "C" {
    pub fn GDALRATClone(arg1: GDALRasterAttributeTableH) -> GDALRasterAttributeTableH;
}
extern "C" {
    pub fn GDALRATSerializeJSON(arg1: GDALRasterAttributeTableH) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALRATGetRowOfValue(arg1: GDALRasterAttributeTableH, arg2: f64) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetCacheMax(nBytes: libc::c_int);
}
extern "C" {
    pub fn GDALGetCacheMax() -> libc::c_int;
}
extern "C" {
    pub fn GDALGetCacheUsed() -> libc::c_int;
}
extern "C" {
    pub fn GDALSetCacheMax64(nBytes: GIntBig);
}
extern "C" {
    pub fn GDALGetCacheMax64() -> GIntBig;
}
extern "C" {
    pub fn GDALGetCacheUsed64() -> GIntBig;
}
extern "C" {
    pub fn GDALFlushCacheBlock() -> libc::c_int;
}
extern "C" {
    pub fn GDALDatasetGetVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        nPixelSpace: libc::c_int,
        nLineSpace: GIntBig,
        nBandSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: GIntBig,
        nCacheSize: usize,
        nPageSizeHint: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALGetVirtualMemAuto(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        pnPixelSpace: *mut libc::c_int,
        pnLineSpace: *mut GIntBig,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut CPLVirtualMem;
}
pub mod GDALTileOrganization {
    pub type Type = u32;
    /// Tile Interleaved by Pixel: tile (0,0) with internal band interleaved by pixel organization, tile (1, 0), ...
    pub const GTO_TIP: Type = 0;
    /// Band Interleaved by Tile : tile (0,0) of first band, tile (0,0) of second band, ... tile (1,0) of fisrt band, tile (1,0) of second band, ...
    pub const GTO_BIT: Type = 1;
    /// Band SeQuential : all the tiles of first band, all the tiles of following band...
    pub const GTO_BSQ: Type = 2;
}
extern "C" {
    pub fn GDALDatasetGetTiledVirtualMem(
        hDS: GDALDatasetH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nTileXSize: libc::c_int,
        nTileYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nBandCount: libc::c_int,
        panBandMap: *mut libc::c_int,
        eTileOrganization: GDALTileOrganization::Type,
        nCacheSize: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALRasterBandGetTiledVirtualMem(
        hBand: GDALRasterBandH,
        eRWFlag: GDALRWFlag::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        nTileXSize: libc::c_int,
        nTileYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nCacheSize: usize,
        bSingleThreadUsage: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut CPLVirtualMem;
}
extern "C" {
    pub fn GDALGetJPEG2000Structure(
        pszFilename: *const libc::c_char,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALComputeMedianCutPCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        pfnIncludePixel: ::std::option::Option<
            unsafe extern "C" fn(arg1: libc::c_int, arg2: libc::c_int, arg3: *mut libc::c_void)
                -> libc::c_int,
        >,
        nColors: libc::c_int,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALDitherRGB2PCT(
        hRed: GDALRasterBandH,
        hGreen: GDALRasterBandH,
        hBlue: GDALRasterBandH,
        hTarget: GDALRasterBandH,
        hColorTable: GDALColorTableH,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALChecksumImage(
        hBand: GDALRasterBandH,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALComputeProximity(
        hSrcBand: GDALRasterBandH,
        hProximityBand: GDALRasterBandH,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFillNodata(
        hTargetBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        dfMaxSearchDist: f64,
        bDeprecatedOption: libc::c_int,
        nSmoothingIterations: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALFPolygonize(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hOutLayer: OGRLayerH,
        iPixValField: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSieveFilter(
        hSrcBand: GDALRasterBandH,
        hMaskBand: GDALRasterBandH,
        hDstBand: GDALRasterBandH,
        nSizeThreshold: libc::c_int,
        nConnectedness: libc::c_int,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub type GDALTransformerFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pTransformerArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALDestroyTransformer(pTransformerArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALUseTransformer(
        pTranformerArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateSimilarTransformer(
        psTransformerArg: *mut libc::c_void,
        dfSrcRatioX: f64,
        dfSrcRatioY: f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const libc::c_char,
        bGCPUseOK: libc::c_int,
        dfGCPErrorThreshold: f64,
        nOrder: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer2(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGenImgProjTransformer3(
        pszSrcWKT: *const libc::c_char,
        padfSrcGeoTransform: *const f64,
        pszDstWKT: *const libc::c_char,
        padfDstGeoTransform: *const f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALSetGenImgProjTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALDestroyGenImgProjTransformer(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGenImgProjTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSetTransformerDstGeoTransform(arg1: *mut libc::c_void, arg2: *const f64);
}
extern "C" {
    pub fn GDALCreateReprojectionTransformer(
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyReprojectionTransformer(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn GDALReprojectionTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateGCPTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: libc::c_int,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALCreateGCPRefineTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        nReqOrder: libc::c_int,
        bReversed: libc::c_int,
        tolerance: f64,
        minimumGcps: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyGCPTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGCPTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateTPSTransformer(
        nGCPCount: libc::c_int,
        pasGCPList: *const GDAL_GCP,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyTPSTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALTPSTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateRPCTransformer(
        psRPC: *mut GDALRPCInfo,
        bReversed: libc::c_int,
        dfPixErrThreshold: f64,
        papszOptions: *mut *mut libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyRPCTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALRPCTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateGeoLocTransformer(
        hBaseDS: GDALDatasetH,
        papszGeolocationInfo: *mut *mut libc::c_char,
        bReversed: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALDestroyGeoLocTransformer(pTransformArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALGeoLocTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALCreateApproxTransformer(
        pfnRawTransformer: GDALTransformerFunc,
        pRawTransformerArg: *mut libc::c_void,
        dfMaxError: f64,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn GDALApproxTransformerOwnsSubtransformer(
        pCBData: *mut libc::c_void,
        bOwnFlag: libc::c_int,
    );
}
extern "C" {
    pub fn GDALDestroyApproxTransformer(pApproxArg: *mut libc::c_void);
}
extern "C" {
    pub fn GDALApproxTransform(
        pTransformArg: *mut libc::c_void,
        bDstToSrc: libc::c_int,
        nPointCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        panSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSimpleImageWarp(
        hSrcDS: GDALDatasetH,
        hDstDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        pfnTransform: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        papszWarpOptions: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut libc::c_int,
        pnLines: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSuggestedWarpOutput2(
        hSrcDS: GDALDatasetH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeoTransformOut: *mut f64,
        pnPixels: *mut libc::c_int,
        pnLines: *mut libc::c_int,
        padfExtents: *mut f64,
        nOptions: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALSerializeTransformer(
        pfnFunc: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
    ) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeTransformer(
        psTree: *mut CPLXMLNode,
        ppfnFunc: *mut GDALTransformerFunc,
        ppTransformArg: *mut *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALTransformGeolocations(
        hXBand: GDALRasterBandH,
        hYBand: GDALRasterBandH,
        hZBand: GDALRasterBandH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        papszOptions: *mut *mut libc::c_char,
    ) -> CPLErr::Type;
}
pub type GDALContourWriter = ::std::option::Option<
    unsafe extern "C" fn(
        dfLevel: f64,
        nPoints: libc::c_int,
        padfX: *mut f64,
        padfY: *mut f64,
        arg1: *mut libc::c_void,
    ) -> CPLErr::Type,
>;
pub type GDALContourGeneratorH = *mut libc::c_void;
extern "C" {
    pub fn GDAL_CG_Create(
        nWidth: libc::c_int,
        nHeight: libc::c_int,
        bNoDataSet: libc::c_int,
        dfNoDataValue: f64,
        dfContourInterval: f64,
        dfContourBase: f64,
        pfnWriter: GDALContourWriter,
        pCBData: *mut libc::c_void,
    ) -> GDALContourGeneratorH;
}
extern "C" {
    pub fn GDAL_CG_FeedLine(hCG: GDALContourGeneratorH, padfScanline: *mut f64) -> CPLErr::Type;
}
extern "C" {
    pub fn GDAL_CG_Destroy(hCG: GDALContourGeneratorH);
}
extern "C" {
    pub fn OGRContourWriter(
        arg1: f64,
        arg2: libc::c_int,
        arg3: *mut f64,
        arg4: *mut f64,
        pInfo: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALContourGenerate(
        hBand: GDALRasterBandH,
        dfContourInterval: f64,
        dfContourBase: f64,
        nFixedLevelCount: libc::c_int,
        padfFixedLevels: *mut f64,
        bUseNoData: libc::c_int,
        dfNoDataValue: f64,
        hLayer: *mut libc::c_void,
        iIDField: libc::c_int,
        iElevField: libc::c_int,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {

    pub fn GDALRasterizeGeometries(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        nGeomCount: libc::c_int,
        pahGeometries: *mut OGRGeometryH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfGeomBurnValue: *mut f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayers(
        hDS: GDALDatasetH,
        nBandCount: libc::c_int,
        panBandList: *mut libc::c_int,
        nLayerCount: libc::c_int,
        pahLayers: *mut OGRLayerH,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        padfLayerBurnValues: *mut f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALRasterizeLayersBuf(
        pData: *mut libc::c_void,
        nBufXSize: libc::c_int,
        nBufYSize: libc::c_int,
        eBufType: GDALDataType::Type,
        nPixelSpace: libc::c_int,
        nLineSpace: libc::c_int,
        nLayerCount: libc::c_int,
        pahLayers: *mut OGRLayerH,
        pszDstProjection: *const libc::c_char,
        padfDstGeoTransform: *mut f64,
        pfnTransformer: GDALTransformerFunc,
        pTransformArg: *mut libc::c_void,
        dfBurnValue: f64,
        papszOptions: *mut *mut libc::c_char,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
    ) -> CPLErr::Type;
}
pub mod GDALGridAlgorithm {
    /// Gridding Algorithms
    pub type Type = u32;
    /// Inverse distance to a power
    pub const GGA_InverseDistanceToAPower: Type = 1;
    /// Moving Average
    pub const GGA_MovingAverage: Type = 2;
    /// Nearest Neighbor
    pub const GGA_NearestNeighbor: Type = 3;
    /// Minimum Value (Data Metric)
    pub const GGA_MetricMinimum: Type = 4;
    /// Maximum Value (Data Metric)
    pub const GGA_MetricMaximum: Type = 5;
    /// Data Range (Data Metric)
    pub const GGA_MetricRange: Type = 6;
    /// Number of Points (Data Metric)
    pub const GGA_MetricCount: Type = 7;
    /// Average Distance (Data Metric)
    pub const GGA_MetricAverageDistance: Type = 8;
    /// Average Distance Between Data Points (Data Metric)
    pub const GGA_MetricAverageDistancePts: Type = 9;
}
extern "C" {
    pub fn GDALGridCreate(
        arg1: GDALGridAlgorithm::Type,
        arg2: *const libc::c_void,
        arg3: GUInt32,
        arg4: *const f64,
        arg5: *const f64,
        arg6: *const f64,
        arg7: f64,
        arg8: f64,
        arg9: f64,
        arg10: f64,
        arg11: GUInt32,
        arg12: GUInt32,
        arg13: GDALDataType::Type,
        arg14: *mut libc::c_void,
        arg15: GDALProgressFunc,
        arg16: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALComputeMatchingPoints(
        hFirstImage: GDALDatasetH,
        hSecondImage: GDALDatasetH,
        papszOptions: *mut *mut libc::c_char,
        pnGCPCount: *mut libc::c_int,
    ) -> *mut GDAL_GCP;
}
pub type CPLThreadFunc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>;
extern "C" {
    pub fn CPLLockFile(pszPath: *const libc::c_char, dfWaitInSeconds: f64) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLUnlockFile(hLock: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCreateMutex() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateMutexEx(nOptions: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutex(
        arg1: *mut *mut libc::c_void,
        dfWaitInSeconds: f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateOrAcquireMutexEx(
        arg1: *mut *mut libc::c_void,
        dfWaitInSeconds: f64,
        nOptions: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn CPLAcquireMutex(hMutex: *mut libc::c_void, dfWaitInSeconds: f64) -> libc::c_int;
}
extern "C" {
    pub fn CPLReleaseMutex(hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLDestroyMutex(hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCleanupMasterMutex();
}
extern "C" {
    pub fn CPLCreateCond() -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLCondWait(hCond: *mut libc::c_void, hMutex: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCondSignal(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLCondBroadcast(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLDestroyCond(hCond: *mut libc::c_void);
}
extern "C" {
    pub fn CPLGetPID() -> GIntBig;
}
extern "C" {
    pub fn CPLCreateThread(pfnMain: CPLThreadFunc, pArg: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn CPLCreateJoinableThread(
        pfnMain: CPLThreadFunc,
        pArg: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLJoinThread(hJoinableThread: *mut libc::c_void);
}
extern "C" {
    pub fn CPLSleep(dfWaitInSeconds: f64);
}
extern "C" {
    pub fn CPLGetThreadingModel() -> *const libc::c_char;
}
extern "C" {
    pub fn CPLGetNumCPUs() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CPLLock {
    _unused: [u8; 0],
}
pub type CPLLock = _CPLLock;
pub mod CPLLockType {
    pub type Type = u32;
    pub const LOCK_RECURSIVE_MUTEX: Type = 0;
    pub const LOCK_ADAPTIVE_MUTEX: Type = 1;
    pub const LOCK_SPIN: Type = 2;
}
extern "C" {
    pub fn CPLCreateLock(eType: CPLLockType::Type) -> *mut CPLLock;
}
extern "C" {
    pub fn CPLCreateOrAcquireLock(arg1: *mut *mut CPLLock, eType: CPLLockType::Type)
        -> libc::c_int;
}
extern "C" {
    pub fn CPLAcquireLock(arg1: *mut CPLLock) -> libc::c_int;
}
extern "C" {
    pub fn CPLReleaseLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLDestroyLock(arg1: *mut CPLLock);
}
extern "C" {
    pub fn CPLLockSetDebugPerf(arg1: *mut CPLLock, bEnableIn: libc::c_int);
}
extern "C" {
    pub fn CPLGetTLS(nIndex: libc::c_int) -> *mut libc::c_void;
}
extern "C" {
    pub fn CPLSetTLS(nIndex: libc::c_int, pData: *mut libc::c_void, bFreeOnExit: libc::c_int);
}
pub type CPLTLSFreeFunc = ::std::option::Option<unsafe extern "C" fn(pData: *mut libc::c_void)>;
extern "C" {
    pub fn CPLSetTLSWithFreeFunc(
        nIndex: libc::c_int,
        pData: *mut libc::c_void,
        pfnFree: CPLTLSFreeFunc,
    );
}
extern "C" {
    pub fn CPLCleanupTLS();
}
pub mod GDALResampleAlg {
    /// Warp Resampling Algorithm
    pub type Type = u32;
    /// Nearest neighbour (select on one input pixel)
    pub const GRA_NearestNeighbour: Type = 0;
    /// Bilinear (2x2 kernel)
    pub const GRA_Bilinear: Type = 1;
    /// Cubic Convolution Approximation (4x4 kernel)
    pub const GRA_Cubic: Type = 2;
    /// Cubic B-Spline Approximation (4x4 kernel)
    pub const GRA_CubicSpline: Type = 3;
    /// Lanczos windowed sinc interpolation (6x6 kernel)
    pub const GRA_Lanczos: Type = 4;
    /// Average (computes the average of all non-NODATA contributing pixels)
    pub const GRA_Average: Type = 5;
    /// Mode (selects the value which appears most often of all the sampled points)
    pub const GRA_Mode: Type = 6;
    /// Max (selects maximum of all non-NODATA contributing pixels)
    pub const GRA_Max: Type = 8;
    /// Min (selects minimum of all non-NODATA contributing pixels)
    pub const GRA_Min: Type = 9;
    /// Med (selects median of all non-NODATA contributing pixels)
    pub const GRA_Med: Type = 10;
    /// Q1 (selects first quartile of all non-NODATA contributing pixels)
    pub const GRA_Q1: Type = 11;
    /// Q3 (selects third quartile of all non-NODATA contributing pixels)
    pub const GRA_Q3: Type = 12;
}
pub type GDALMaskFunc = ::std::option::Option<
    unsafe extern "C" fn(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pMask: *mut libc::c_void,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn GDALWarpNoDataMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        papabyImageData: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
        pbOutAllValid: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpDstAlphaMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcAlphaMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
        pbOutAllOpaque: *mut libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpSrcMaskMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpCutlineMasker(
        pMaskFuncArg: *mut libc::c_void,
        nBandCount: libc::c_int,
        eType: GDALDataType::Type,
        nXOff: libc::c_int,
        nYOff: libc::c_int,
        nXSize: libc::c_int,
        nYSize: libc::c_int,
        arg1: *mut *mut GByte,
        bMaskIsFloat: libc::c_int,
        pValidityMask: *mut libc::c_void,
    ) -> CPLErr::Type;
}
/// Warp control options for use with GDALWarpOperation::Initialize()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GDALWarpOptions {
    pub papszWarpOptions: *mut *mut libc::c_char,
    /// In bytes, 0.0 for internal default
    pub dfWarpMemoryLimit: f64,
    /// Resampling algorithm to use
    pub eResampleAlg: GDALResampleAlg::Type,
    /// data type to use during warp operation, GDT_Unknown lets the algorithm
    /// select the type
    pub eWorkingDataType: GDALDataType::Type,
    /// Source image dataset.
    pub hSrcDS: GDALDatasetH,
    /// Destination image dataset - may be NULL if only using GDALWarpOperation::WarpRegionToBuffer().
    pub hDstDS: GDALDatasetH,
    /// Number of bands to process, may be 0 to select all bands.
    pub nBandCount: libc::c_int,
    /// The band numbers for the source bands to process (1 based)
    pub panSrcBands: *mut libc::c_int,
    /// The band numbers for the destination bands to process (1 based)
    pub panDstBands: *mut libc::c_int,
    /// The source band so use as an alpha (transparency) value, 0=disabled
    pub nSrcAlphaBand: libc::c_int,
    /// The dest. band so use as an alpha (transparency) value, 0=disabled
    pub nDstAlphaBand: libc::c_int,
    /// The "nodata" value real component for each input band, if NULL there isn't one
    pub padfSrcNoDataReal: *mut f64,
    /// The "nodata" value imaginary component - may be NULL even if real
    /// component is provided.
    pub padfSrcNoDataImag: *mut f64,
    /// The "nodata" value real component for each output band, if NULL there isn't one
    pub padfDstNoDataReal: *mut f64,
    /// The "nodata" value imaginary component - may be NULL even if real
    /// component is provided.
    pub padfDstNoDataImag: *mut f64,
    /// GDALProgressFunc() compatible progress reporting function, or NULL
    /// if there isn't one.
    pub pfnProgress: GDALProgressFunc,
    /// Callback argument to be passed to pfnProgress.
    pub pProgressArg: *mut libc::c_void,
    /// Type of spatial point transformer function
    pub pfnTransformer: GDALTransformerFunc,
    /// Handle to image transformer setup structure
    pub pTransformerArg: *mut libc::c_void,
    pub papfnSrcPerBandValidityMaskFunc: *mut GDALMaskFunc,
    pub papSrcPerBandValidityMaskFuncArg: *mut *mut libc::c_void,
    pub pfnSrcValidityMaskFunc: GDALMaskFunc,
    pub pSrcValidityMaskFuncArg: *mut libc::c_void,
    pub pfnSrcDensityMaskFunc: GDALMaskFunc,
    pub pSrcDensityMaskFuncArg: *mut libc::c_void,
    pub pfnDstDensityMaskFunc: GDALMaskFunc,
    pub pDstDensityMaskFuncArg: *mut libc::c_void,
    pub pfnDstValidityMaskFunc: GDALMaskFunc,
    pub pDstValidityMaskFuncArg: *mut libc::c_void,
    pub pfnPreWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(pKern: *mut libc::c_void, pArg: *mut libc::c_void) -> CPLErr::Type,
    >,
    pub pPreWarpProcessorArg: *mut libc::c_void,
    pub pfnPostWarpChunkProcessor: ::std::option::Option<
        unsafe extern "C" fn(pKern: *mut libc::c_void, pArg: *mut libc::c_void) -> CPLErr::Type,
    >,
    pub pPostWarpProcessorArg: *mut libc::c_void,
    /// Optional OGRPolygonH for a masking cutline.
    pub hCutline: *mut libc::c_void,
    /// Optional blending distance to apply across cutline in pixels, default is zero.
    pub dfCutlineBlendDist: f64,
}
#[test]
fn bindgen_test_layout_GDALWarpOptions() {
    assert_eq!(
        ::std::mem::size_of::<GDALWarpOptions>(),
        264usize,
        concat!("Size of: ", stringify!(GDALWarpOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<GDALWarpOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(GDALWarpOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).papszWarpOptions as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papszWarpOptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).dfWarpMemoryLimit as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(dfWarpMemoryLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).eResampleAlg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(eResampleAlg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).eWorkingDataType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(eWorkingDataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).hSrcDS as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hSrcDS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).hDstDS as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hDstDS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).nBandCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nBandCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).panSrcBands as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(panSrcBands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).panDstBands as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(panDstBands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).nSrcAlphaBand as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nSrcAlphaBand)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).nDstAlphaBand as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(nDstAlphaBand)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfSrcNoDataReal as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfSrcNoDataReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfSrcNoDataImag as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfSrcNoDataImag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfDstNoDataReal as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfDstNoDataReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).padfDstNoDataImag as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(padfDstNoDataImag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pfnProgress as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnProgress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pProgressArg as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pProgressArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pfnTransformer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnTransformer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).pTransformerArg as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pTransformerArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).papfnSrcPerBandValidityMaskFunc as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papfnSrcPerBandValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).papSrcPerBandValidityMaskFuncArg as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(papSrcPerBandValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnSrcValidityMaskFunc as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnSrcValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pSrcValidityMaskFuncArg as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pSrcValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnSrcDensityMaskFunc as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnSrcDensityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pSrcDensityMaskFuncArg as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pSrcDensityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnDstDensityMaskFunc as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnDstDensityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pDstDensityMaskFuncArg as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pDstDensityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnDstValidityMaskFunc as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnDstValidityMaskFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pDstValidityMaskFuncArg as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pDstValidityMaskFuncArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnPreWarpChunkProcessor as *const _
                as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnPreWarpChunkProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pPreWarpProcessorArg as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pPreWarpProcessorArg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pfnPostWarpChunkProcessor as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pfnPostWarpChunkProcessor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).pPostWarpProcessorArg as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(pPostWarpProcessorArg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GDALWarpOptions>())).hCutline as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(hCutline)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<GDALWarpOptions>())).dfCutlineBlendDist as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(GDALWarpOptions),
            "::",
            stringify!(dfCutlineBlendDist)
        )
    );
}
extern "C" {
    pub fn GDALCreateWarpOptions() -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALDestroyWarpOptions(arg1: *mut GDALWarpOptions);
}
extern "C" {
    pub fn GDALCloneWarpOptions(arg1: *const GDALWarpOptions) -> *mut GDALWarpOptions;
}
extern "C" {
    pub fn GDALSerializeWarpOptions(arg1: *const GDALWarpOptions) -> *mut CPLXMLNode;
}
extern "C" {
    pub fn GDALDeserializeWarpOptions(arg1: *mut CPLXMLNode) -> *mut GDALWarpOptions;
}
extern "C" {

    pub fn GDALReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        hDstDS: GDALDatasetH,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALCreateAndReprojectImage(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstFilename: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        hDstDriver: GDALDriverH,
        papszCreateOptions: *mut *mut libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfWarpMemoryLimit: f64,
        dfMaxError: f64,
        pfnProgress: GDALProgressFunc,
        pProgressArg: *mut libc::c_void,
        psOptions: *mut GDALWarpOptions,
    ) -> CPLErr::Type;
}
extern "C" {

    pub fn GDALAutoCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        pszSrcWKT: *const libc::c_char,
        pszDstWKT: *const libc::c_char,
        eResampleAlg: GDALResampleAlg::Type,
        dfMaxError: f64,
        psOptions: *const GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALCreateWarpedVRT(
        hSrcDS: GDALDatasetH,
        nPixels: libc::c_int,
        nLines: libc::c_int,
        padfGeoTransform: *mut f64,
        psOptions: *mut GDALWarpOptions,
    ) -> GDALDatasetH;
}
extern "C" {
    pub fn GDALInitializeWarpedVRT(hDS: GDALDatasetH, psWO: *mut GDALWarpOptions) -> CPLErr::Type;
}
pub type GDALWarpOperationH = *mut libc::c_void;
extern "C" {
    pub fn GDALCreateWarpOperation(arg1: *const GDALWarpOptions) -> GDALWarpOperationH;
}
extern "C" {
    pub fn GDALDestroyWarpOperation(arg1: GDALWarpOperationH);
}
extern "C" {
    pub fn GDALChunkAndWarpImage(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALChunkAndWarpMulti(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegion(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> CPLErr::Type;
}
extern "C" {
    pub fn GDALWarpRegionToBuffer(
        arg1: GDALWarpOperationH,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_void,
        arg7: GDALDataType::Type,
        arg8: libc::c_int,
        arg9: libc::c_int,
        arg10: libc::c_int,
        arg11: libc::c_int,
    ) -> CPLErr::Type;
}
pub mod OGRAxisOrientation {
    /// \file ogr_srs_api.h
    ///
    /// C spatial reference system services and defines.
    ///
    /// See also: ogr_spatialref.h
    pub type Type = u32;
    pub const OAO_Other: Type = 0;
    pub const OAO_North: Type = 1;
    pub const OAO_South: Type = 2;
    pub const OAO_East: Type = 3;
    pub const OAO_West: Type = 4;
    pub const OAO_Up: Type = 5;
    pub const OAO_Down: Type = 6;
}
extern "C" {
    pub fn OSRAxisEnumToName(eOrientation: OGRAxisOrientation::Type) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRNewSpatialReference(arg1: *const libc::c_char) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRCloneGeogCS(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRClone(arg1: OGRSpatialReferenceH) -> OGRSpatialReferenceH;
}
extern "C" {
    pub fn OSRDestroySpatialReference(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRReference(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRDereference(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRRelease(arg1: OGRSpatialReferenceH);
}
extern "C" {
    pub fn OSRValidate(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRFixupOrdering(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRFixup(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRStripCTParms(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSG(arg1: OGRSpatialReferenceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromEPSGA(arg1: OGRSpatialReferenceH, arg2: libc::c_int) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromESRI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPCI(
        hSRS: OGRSpatialReferenceH,
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: libc::c_long,
        arg3: libc::c_long,
        arg4: *mut f64,
        arg5: libc::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromXML(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromDict(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: libc::c_long,
        arg3: libc::c_long,
        arg4: libc::c_long,
        arg5: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromOzi(
        arg1: OGRSpatialReferenceH,
        arg2: *const *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromERM(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRImportFromUrl(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToWkt(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char)
        -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPrettyWkt(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToProj4(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPCI(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: *mut *mut libc::c_char,
        arg4: *mut *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToUSGS(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_long,
        arg3: *mut libc::c_long,
        arg4: *mut *mut f64,
        arg5: *mut libc::c_long,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToXML(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
        arg3: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToPanorama(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_long,
        arg3: *mut libc::c_long,
        arg4: *mut libc::c_long,
        arg5: *mut libc::c_long,
        arg6: *mut f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToMICoordSys(
        arg1: OGRSpatialReferenceH,
        arg2: *mut *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRExportToERM(
        arg1: OGRSpatialReferenceH,
        arg2: *mut libc::c_char,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphToESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRMorphFromESRI(arg1: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszNodePath: *const libc::c_char,
        pszNewNodeValue: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAttrValue(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
        iChild: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetAngularUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAngularUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRSetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetLinearUnitsAndUpdateParameters(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetLinearUnits(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRGetTargetLinearUnits(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> f64;
}
extern "C" {
    pub fn OSRGetPrimeMeridian(arg1: OGRSpatialReferenceH, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn OSRIsGeographic(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsLocal(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsProjected(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsCompound(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsGeocentric(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsVertical(arg1: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameGeogCS(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSameVertCS(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRIsSame(arg1: OGRSpatialReferenceH, arg2: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetLocalCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeocCS(hSRS: OGRSpatialReferenceH, pszName: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetWellKnownGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetFromUserInput(
        hSRS: OGRSpatialReferenceH,
        arg1: *const libc::c_char,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCopyGeogCSFrom(
        hSRS: OGRSpatialReferenceH,
        hSrcSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: f64,
        arg2: f64,
        arg3: f64,
        arg4: f64,
        arg5: f64,
        arg6: f64,
        arg7: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetTOWGS84(
        hSRS: OGRSpatialReferenceH,
        arg1: *mut f64,
        arg2: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetCompoundCS(
        hSRS: OGRSpatialReferenceH,
        pszName: *const libc::c_char,
        hHorizSRS: OGRSpatialReferenceH,
        hVertSRS: OGRSpatialReferenceH,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetGeogCS(
        hSRS: OGRSpatialReferenceH,
        pszGeogName: *const libc::c_char,
        pszDatumName: *const libc::c_char,
        pszEllipsoidName: *const libc::c_char,
        dfSemiMajor: f64,
        dfInvFlattening: f64,
        pszPMName: *const libc::c_char,
        dfPMOffset: f64,
        pszUnits: *const libc::c_char,
        dfConvertToRadians: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetVertCS(
        hSRS: OGRSpatialReferenceH,
        pszVertCSName: *const libc::c_char,
        pszVertDatumName: *const libc::c_char,
        nVertDatumType: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetSemiMajor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetSemiMinor(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRGetInvFlattening(arg1: OGRSpatialReferenceH, arg2: *mut OGRErr::Type) -> f64;
}
extern "C" {
    pub fn OSRSetAuthority(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        pszAuthority: *const libc::c_char,
        nCode: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetAuthorityCode(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRGetAuthorityName(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetProjection(arg1: OGRSpatialReferenceH, arg2: *const libc::c_char) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParmName: *const libc::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetNormProjParm(
        arg1: OGRSpatialReferenceH,
        arg2: *const libc::c_char,
        arg3: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetNormProjParm(
        hSRS: OGRSpatialReferenceH,
        pszParmName: *const libc::c_char,
        dfDefault: f64,
        arg1: *mut OGRErr::Type,
    ) -> f64;
}
extern "C" {
    pub fn OSRSetUTM(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNorth: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRGetUTMZone(hSRS: OGRSpatialReferenceH, pbNorth: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn OSRSetStatePlane(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNAD83: libc::c_int,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetStatePlaneWithUnits(
        hSRS: OGRSpatialReferenceH,
        nZone: libc::c_int,
        bNAD83: libc::c_int,
        pszOverrideUnitName: *const libc::c_char,
        dfOverrideUnit: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRAutoIdentifyEPSG(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    pub fn OSREPSGTreatsAsLatLong(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSREPSGTreatsAsNorthingEasting(hSRS: OGRSpatialReferenceH) -> libc::c_int;
}
extern "C" {
    pub fn OSRGetAxis(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        iAxis: libc::c_int,
        peOrientation: *mut OGRAxisOrientation::Type,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn OSRSetAxes(
        hSRS: OGRSpatialReferenceH,
        pszTargetKey: *const libc::c_char,
        pszXAxisName: *const libc::c_char,
        eXAxisOrientation: OGRAxisOrientation::Type,
        pszYAxisName: *const libc::c_char,
        eYAxisOrientation: OGRAxisOrientation::Type,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Albers Conic Equal Area
    pub fn OSRSetACEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Azimuthal Equidistant
    pub fn OSRSetAE(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Bonne
    pub fn OSRSetBonne(
        hSRS: OGRSpatialReferenceH,
        dfStandardParallel: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Cylindrical Equal Area
    pub fn OSRSetCEA(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Cassini-Soldner
    pub fn OSRSetCS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Equidistant Conic
    pub fn OSRSetEC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Eckert I-VI
    pub fn OSRSetEckert(
        hSRS: OGRSpatialReferenceH,
        nVariation: libc::c_int,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Eckert IV
    pub fn OSRSetEckertIV(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Eckert VI
    pub fn OSRSetEckertVI(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Equirectangular
    pub fn OSRSetEquirectangular(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Equirectangular generalized form
    pub fn OSRSetEquirectangular2(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfPseudoStdParallel1: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Gall Stereograpic
    pub fn OSRSetGS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Goode Homolosine
    pub fn OSRSetGH(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Interrupted Goode Homolosine
    pub fn OSRSetIGH(hSRS: OGRSpatialReferenceH) -> OGRErr::Type;
}
extern "C" {
    /// GEOS - Geostationary Satellite View
    pub fn OSRSetGEOS(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfSatelliteHeight: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Gauss Schreiber Transverse Mercator
    pub fn OSRSetGaussSchreiberTMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Gnomonic
    pub fn OSRSetGnomonic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Oblique Mercator (aka HOM (variant B)
    pub fn OSRSetOM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Hotine Oblique Mercator using azimuth angle
    pub fn OSRSetHOM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetHOMAC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfRectToSkew: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Hotine Oblique Mercator using two points on centerline
    pub fn OSRSetHOM2PNO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// International Map of the World Polyconic
    pub fn OSRSetIWMPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLat2: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Krovak Oblique Conic Conformal
    pub fn OSRSetKrovak(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfAzimuth: f64,
        dfPseudoStdParallelLat: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Lambert Azimuthal Equal-Area
    pub fn OSRSetLAEA(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Lambert Conformal Conic
    pub fn OSRSetLCC(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Lambert Conformal Conic 1SP
    pub fn OSRSetLCC1SP(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Lambert Conformal Conic (Belgium)
    pub fn OSRSetLCCB(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfStdP2: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Miller Cylindrical
    pub fn OSRSetMC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Mercator
    pub fn OSRSetMercator(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetMercator2SP(
        hSRS: OGRSpatialReferenceH,
        dfStdP1: f64,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Mollweide
    pub fn OSRSetMollweide(
        hSRS: OGRSpatialReferenceH,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// New Zealand Map Grid
    pub fn OSRSetNZMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Oblique Stereographic
    pub fn OSRSetOS(
        hSRS: OGRSpatialReferenceH,
        dfOriginLat: f64,
        dfCMeridian: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Orthographic
    pub fn OSRSetOrthographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Polyconic
    pub fn OSRSetPolyconic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Polar Stereographic
    pub fn OSRSetPS(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Robinson
    pub fn OSRSetRobinson(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Sinusoidal
    pub fn OSRSetSinusoidal(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Stereographic
    pub fn OSRSetStereographic(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Swiss Oblique Cylindrical
    pub fn OSRSetSOC(
        hSRS: OGRSpatialReferenceH,
        dfLatitudeOfOrigin: f64,
        dfCentralMeridian: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Transverse Mercator
    ///
    /// Special processing available for Transverse Mercator with GDAL &gt;= 1.10 and PROJ &gt;= 4.8 :
    /// see OGRSpatialReference::exportToProj4().
    pub fn OSRSetTM(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Transverse Mercator variant
    pub fn OSRSetTMVariant(
        hSRS: OGRSpatialReferenceH,
        pszVariantName: *const libc::c_char,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Tunesia Mining Grid
    pub fn OSRSetTMG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Transverse Mercator (South Oriented)
    pub fn OSRSetTMSO(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
        dfScale: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRSetTPED(
        hSRS: OGRSpatialReferenceH,
        dfLat1: f64,
        dfLong1: f64,
        dfLat2: f64,
        dfLong2: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// VanDerGrinten
    pub fn OSRSetVDG(
        hSRS: OGRSpatialReferenceH,
        dfCenterLong: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Wagner I -- VII
    pub fn OSRSetWagner(
        hSRS: OGRSpatialReferenceH,
        nVariation: libc::c_int,
        dfCenterLat: f64,
        dfFalseEasting: f64,
        dfFalseNorthing: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    /// Quadrilateralized Spherical Cube
    pub fn OSRSetQSC(
        hSRS: OGRSpatialReferenceH,
        dfCenterLat: f64,
        dfCenterLong: f64,
    ) -> OGRErr::Type;
}
extern "C" {
    pub fn OSRCalcInvFlattening(dfSemiMajor: f64, dfSemiMinor: f64) -> f64;
}
extern "C" {
    pub fn OSRCalcSemiMinorFromInvFlattening(dfSemiMajor: f64, dfInvFlattening: f64) -> f64;
}
extern "C" {
    pub fn OSRCleanup();
}
extern "C" {
    pub fn OCTNewCoordinateTransformation(
        hSourceSRS: OGRSpatialReferenceH,
        hTargetSRS: OGRSpatialReferenceH,
    ) -> OGRCoordinateTransformationH;
}
extern "C" {
    pub fn OCTDestroyCoordinateTransformation(arg1: OGRCoordinateTransformationH);
}
extern "C" {
    pub fn OCTTransform(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTTransformEx(
        hCT: OGRCoordinateTransformationH,
        nCount: libc::c_int,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        pabSuccess: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn OCTProj4Normalize(pszProj4Src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn OCTCleanupProjMutex();
}
pub mod OGRErr {
    /// Type for a OGR error
    ///
    /// <div rustbindgen replaces="OGRErr"></div>
    pub type Type = u32;
    /// Success
    ///
    /// <div rustbindgen replaces="OGRERR_NONE"></div>
    pub const OGRERR_NONE: Type = 0;
    /// Not enough data to deserialize
    ///
    /// <div rustbindgen replaces="OGRERR_NOT_ENOUGH_DATA"></div>
    pub const OGRERR_NOT_ENOUGH_DATA: Type = 1;
    /// Not enough memory
    ///
    /// <div rustbindgen replaces="OGRERR_NOT_ENOUGH_MEMORY"></div>
    pub const OGRERR_NOT_ENOUGH_MEMORY: Type = 2;
    /// Unsupported geometry type
    ///
    /// <div rustbindgen replaces="OGRERR_UNSUPPORTED_GEOMETRY_TYPE"></div>
    pub const OGRERR_UNSUPPORTED_GEOMETRY_TYPE: Type = 3;
    /// Unsupported operation
    ///
    /// <div rustbindgen replaces="OGRERR_UNSUPPORTED_OPERATION"></div>
    pub const OGRERR_UNSUPPORTED_OPERATION: Type = 4;
    /// Corrupt data
    ///
    /// <div rustbindgen replaces="OGRERR_CORRUPT_DATA"></div>
    pub const OGRERR_CORRUPT_DATA: Type = 5;
    /// Failure
    ///
    /// <div rustbindgen replaces="OGRERR_FAILURE"></div>
    pub const OGRERR_FAILURE: Type = 6;
    /// Unsupported SRS
    ///
    /// <div rustbindgen replaces="OGRERR_UNSUPPORTED_SRS"></div>
    pub const OGRERR_UNSUPPORTED_SRS: Type = 7;
    /// Invalid handle
    ///
    /// <div rustbindgen replaces="INVALID_HANDLE"></div>
    pub const INVALID_HANDLE: Type = 8;
    /// Non existing feature. Added in GDAL 2.0
    ///
    /// <div rustbindgen replaces="NON_EXISTING_FEATURE"></div>
    pub const NON_EXISTING_FEATURE: Type = 9;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
